/*
Navicat MySQL Data Transfer

Source Server         : localhost_3306
Source Server Version : 50720
Source Host           : localhost:3306
Source Database       : db_blogcrawler

Target Server Type    : MYSQL
Target Server Version : 50720
File Encoding         : 65001

Date: 2019-01-03 17:21:21
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `t_blog`
-- ----------------------------
DROP TABLE IF EXISTS `t_blog`;
CREATE TABLE `t_blog` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(100) DEFAULT NULL,
  `content` text,
  `crawlerDate` datetime DEFAULT NULL,
  `oldUrl` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_blog
-- ----------------------------
INSERT INTO `t_blog` VALUES ('1', '委托', '<h1 style=\"text-align: center\">委托</h1> \n<h3>1.什么是委托？</h3> \n<p>个人理解：委托就是把一个方法当做参数传入另一个方法中进行调用。 （委托的实质就是一个类，可以通过中间语言IL编译工具去查看源码）</p> \n<h3>2.委托的使用？</h3> \n<p>使用委托三部曲：（1）、委托的声明 。&nbsp; &nbsp; &nbsp;（2）、委托的实例化。&nbsp; &nbsp; &nbsp;（3）调用。</p> \n<h3>3.委托的种类？</h3> \n<p>（1）.delegate&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;（2）.泛型委托 Func/ Action&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; （3）. event 和观察者模式&nbsp; &nbsp;</p> \n<p>通过delegate 关键字来声明委托&nbsp;举例：</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: #008080\">1</span>  <span style=\"color: #0000ff\">public</span> <span style=\"color: #0000ff\">delegate</span> <span style=\"color: #0000ff\">void</span><span style=\"color: #000000\"> NoReturnNoPara(); // 无参数、无返回值的委托声明  \n</span><span style=\"color: #008080\">2</span>  <span style=\"color: #0000ff\">public</span> <span style=\"color: #0000ff\">delegate</span> <span style=\"color: #0000ff\">void</span> NoReturnWithPara(<span style=\"color: #0000ff\">int</span> x, <span style=\"color: #0000ff\">int</span> y);<span style=\"color: #008000\">//</span><span style=\"color: #008000\">1 声明委托</span>\n<span style=\"color: #008080\">3</span>  <span style=\"color: #0000ff\">public</span> <span style=\"color: #0000ff\">delegate</span> <span style=\"color: #0000ff\">int</span><span style=\"color: #000000\"> WithReturnNoPara(); //无参数、int类型返回值委托声明\n</span><span style=\"color: #008080\">4</span>  <span style=\"color: #0000ff\">public</span> <span style=\"color: #0000ff\">delegate</span> MyDelegate WithReturnWithPara(<span style=\"color: #0000ff\">out</span> <span style=\"color: #0000ff\">int</span> x, <span style=\"color: #0000ff\">ref</span> <span style=\"color: #0000ff\">int</span> y);//自定义委托类</pre> \n</div> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: #008080\">1</span>   <span style=\"color: #0000ff\">private</span> <span style=\"color: #0000ff\">void</span><span style=\"color: #000000\"> DoNothing()  //无参数无返回值的方法\n</span><span style=\"color: #008080\">2</span> <span style=\"color: #000000\"> {\n</span><span style=\"color: #008080\">3</span>    Console.WriteLine(<span style=\"color: #800000\">\"</span><span style=\"color: #800000\">This is DoNothing 。。。。</span><span style=\"color: #800000\">\"</span><span style=\"color: #000000\">);\n</span><span style=\"color: #008080\">4</span>  }</pre> \n</div> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: #008080\">1</span>  NoReturnNoPara method = <span style=\"color: #0000ff\">new</span> NoReturnNoPara(<span style=\"color: #0000ff\">this</span><span style=\"color: #000000\">.DoNothing);// this表示是当前类的方法，也可以把方法拆分到其他类中。这里是为了使用方便。\n</span><span style=\"color: #008080\">2</span>   <span style=\"color: #008000\">//</span><span style=\"color: #008000\">2 委托的实例化  要求传递一个参数类型 返回值都跟委托一致的方法,</span>\n<span style=\"color: #008080\">3</span>  method.Invoke();<span style=\"color: #008000\">//</span><span style=\"color: #008000\">3委托实例的调用  参数和委托约束的一致</span></pre> \n</div> \n<p>&nbsp; &nbsp; &nbsp; 上述三段代码，第一段是委托类型的声明； 第二段代码是为实例化委托做准备，通过实例化委托将DoNothing方法作为参数传入到委托中；第三段代码是最后调用DoNothing方法，执行DoNothing中的业务逻辑。<span style=\"color: #ff0000\">注意：委托声明、委托的实例化 要求传递一个参数类型 返回值都跟委托一致的方法,委托实例的调用 参数和委托约束的一致。</span></p> \n<p>&nbsp;</p> \n<h3>Action Func&nbsp; .NetFramework3.0出现的</h3> \n<p>Action 系统提供&nbsp; 0到16个泛型参数&nbsp; 不带返回值&nbsp; 委托</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: #008080\">1</span>    <span style=\"color: #008000\">//</span><span style=\"color: #008000\">Action action = new Action(this.DoNothing);</span>\n<span style=\"color: #008080\">2</span>     Action action0 = <span style=\"color: #0000ff\">this</span>.DoNothing;<span style=\"color: #008000\">//</span><span style=\"color: #008000\">是个语法糖，就是编译器帮我们添加上new Action</span>\n<span style=\"color: #008080\">3</span>     action0.Invoke();  </pre> \n</div> \n<p>在这里的action0.invoke()和上述&nbsp;method.Invoke() 执行的结果是一致的。这里推荐使用泛型委托。</p> \n<p>Func 委托： 无参数int类型返回值</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: #008080\">1</span>  <span style=\"color: #0000ff\">public</span> <span style=\"color: #0000ff\">int</span><span style=\"color: #000000\"> Get()\n</span><span style=\"color: #008080\">2</span> <span style=\"color: #000000\">{\n</span><span style=\"color: #008080\">3</span>    <span style=\"color: #0000ff\">return</span> <span style=\"color: #800080\">1</span><span style=\"color: #000000\">;\n</span><span style=\"color: #008080\">4</span> <span style=\"color: #000000\"> }\n</span><span style=\"color: #008080\">5</span> \n<span style=\"color: #008080\">6</span>    <span style=\"color: #008000\">//</span><span style=\"color: #008000\">Func 系统提供  0到16个泛型参数  带泛型返回值  委托</span>\n<span style=\"color: #008080\">7</span>   Func&lt;<span style=\"color: #0000ff\">int</span>&gt; func0 = <span style=\"color: #0000ff\">this</span><span style=\"color: #000000\">.Get;\n</span><span style=\"color: #008080\">8</span>   <span style=\"color: #0000ff\">int</span> iResult = func0.Invoke();</pre> \n</div> \n<p>&nbsp;带参数有返回值的Func委托&nbsp; int类型参数，字符串类型的返回值&nbsp;</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: #008080\">1</span>   <span style=\"color: #0000ff\">private</span> <span style=\"color: #0000ff\">string</span> ToString(<span style=\"color: #0000ff\">int</span><span style=\"color: #000000\"> i)\n</span><span style=\"color: #008080\">2</span> <span style=\"color: #000000\">  {\n</span><span style=\"color: #008080\">3</span>     <span style=\"color: #0000ff\">return</span><span style=\"color: #000000\"> i.ToString();\n</span><span style=\"color: #008080\">4</span> <span style=\"color: #000000\">  }\n</span><span style=\"color: #008080\">5</span>   Func&lt;<span style=\"color: #0000ff\">int</span>, <span style=\"color: #0000ff\">string</span>&gt; func1 = <span style=\"color: #0000ff\">this</span><span style=\"color: #000000\">.ToString; //第一个是参数类型 ，第二个是返回值类型\n</span><span style=\"color: #008080\">6</span>   func1.Invoke(<span style=\"color: #800080\">0</span>); </pre> \n</div> \n<p>&nbsp;</p>', '2019-01-03 17:06:18', 'https://www.cnblogs.com/super-xi-xi/p/10215569.html');
INSERT INTO `t_blog` VALUES ('2', '七牛云关联Windows图床', '<h1 id=\"注册七牛云\">1. 注册七牛云</h1> \n<p><a href=\"https://portal.qiniu.com/create\">七牛云</a> 地址，需要在这里进行注册</p> \n<h1 id=\"完成实名认证\">2.完成实名认证</h1> \n<p>需要上传身份证的正反面以及支付宝做一下认证即可。</p> \n<p>首先进入个人中心</p> \n<p><img src=\"null2019/01/03/23241139-9bc8-4259-afbe-96930524ca4f.png\"></p> \n<p>然后进行实名认证</p> \n<p><img src=\"null2019/01/03/ef7fec1e-6057-4980-b833-c77a95218286.png\"></p> \n<p>由于我已经认证过了，所以显示认证完成，未认证的用户需要按照提示认证，一般来说 5分钟就能完成认证。</p> \n<h1 id=\"创建对象存储\">3. 创建对象存储</h1> \n<p><img src=\"null2019/01/03/db02b49e-710c-4bd2-811b-120318dca465.png\"></p> \n<p>只需要填一下名字，然后因为是图床所以肯定是公开的访问权限。</p> \n<p><img></p> \n<h1 id=\"绑定域名\">4. 绑定域名</h1> \n<p>配置完空间以后就是需要关联域名，配置 CNAME</p> \n<p><img src=\"null2019/01/03/f9098c09-9644-436d-9906-29ffbacf71ef.png\"></p> \n<p>绑定域名，这个域名需要是一个已经备案过的域名。</p> \n<p><img></p> \n<p>只需要填写域名这一项即可，最后就是需要到你的域名管理后台配置一个域名的解析，首先打开这个地址 <a href=\"https://portal.qiniu.com/cdn/domain/\" class=\"uri\">https://portal.qiniu.com/cdn/domain/</a> 然后找到你的域名选择复制CNAME</p> \n<p><img src=\"null2019/01/03/849fe823-aded-48e4-95ad-094b1fab259c.png\"></p> \n<p>然后需要做一个域名解析，比如到阿里云上</p> \n<p><img src=\"null2019/01/03/77f98634-2879-417e-bf73-10d3972825d2.png\"></p> \n<p>等一会会 <a href=\"https://portal.qiniu.com/cdn/domain/\" class=\"uri\">https://portal.qiniu.com/cdn/domain/</a> 打开这个链接如果看到解析成功则说明配置完成了。</p> \n<h1 id=\"关联-picgo\">5. 关联 PicGo</h1> \n<p>这款软件是一个跨平台的图床软件个人觉得很好用。直接百度就可以下载到。</p> \n<p><img src=\"null2019/01/03/b6958ec6-df51-4300-bf9f-d24aff32e77e.png\"></p> \n<p>做完配置，然后确定，设置为默认图床就可以在上传区上传文件了！</p>', '2019-01-03 17:06:29', 'https://www.cnblogs.com/lwen/p/10215402.html');
INSERT INTO `t_blog` VALUES ('3', 'Java基础入门001 - 简介', '<p>Java分为三个体系：</p> \n<ul> \n <li>JavaEE: Java Platform, Enterprise Edition, Java平台企业版</li> \n <li>JavaSE: Java Platform Standard Edition, Java平台标准版</li> \n <li>JavaME: Java Platform Micro Edition, Java平台微型版</li> \n</ul> \n<p>Java特性：</p> \n<ul> \n <li>可移植：不同系统有不同的解释器JVM</li> \n</ul>', '2019-01-03 17:06:29', 'https://www.cnblogs.com/lingling-00/p/10215232.html');
INSERT INTO `t_blog` VALUES ('4', 'HttpClient在.NET Core中的正确打开方式', '<h2 id=\"问题来源\">问题来源</h2> \n<p>长期以来，.NET开发者都通过下面的方式发送http请求：</p> \n<pre class=\"csharp\"><code>using (var httpClient = new HttpClient())\n{\n    var response = await httpClient.GetAsync(uri);\n    \n    //do something with response\n}</code></pre> \n<p>这段代码理论上来说遵守了C#的最佳实践，HttpClient是IDisposable类型，所以我们通过using语法糖来使用HttpClient。微软官方的文档也提到：</p> \n<blockquote> \n <p>As a rule, when you use an IDisposable object, you should declare and instantiate it in a using statement</p> \n</blockquote> \n<p>可是，当我们试图运行下面的测试：</p> \n<pre class=\"csharp\"><code>public async Task SendRequest() \n{\n    Console.WriteLine(\"Starting reqeust\");\n    for(int i = 0; i&lt;10; i++)\n    {\n        using(var client = new HttpClient())\n        {\n            var result = await client.GetAsync(\"http://www.baidu.com\");\n            Console.WriteLine(result.StatusCode);\n        }\n    }\n    Console.WriteLine(\"Reqeust done\");\n}\n</code></pre> \n<p>此时在terminal下列出所有端口：</p> \n<pre class=\"csharp\"><code>netstat -ap tcp | grep -i \"time_wait\"</code></pre> \n<p><img src=\"null2019/01/03/40b1a809-8544-40e4-a80e-66940439dede.png\" alt=\"\" width=\"600\" height=\"800\"><br> 你会发现本地开启了10个端口，这说明HttpClient的工作原理其实跟我们认为的IDisposable是有区别的，如果你把HttpClient用作大规模的Http请求，实际上会创建很多个Http连接，而且这些资源并不能被立即释放。一个显而易见的改进方法是共享同一个HttpClient实例，从而达到节约socket资源的目的。</p> \n<pre class=\"csharp\"><code>private static readonly HttpClient _client = new HttpClient();\npublic async Task SendRequest2() \n{\n    _testOutputHelper.WriteLine(\"Start request\");\n\n    for(int i = 0; i&lt;10; i++)\n    {\n        var result = await _client.GetAsync(\"http://www.baidu.com\");\n        Console.WriteLine(result.StatusCode);\n    }\n    _testOutputHelper.WriteLine(\"Request done\");\n}</code></pre> \n<p>这个方案似乎解决了问题，使用单例的HttpClient的确会减少Socket资源，但是这个方案会引发新的问题：由于这个Http连接始终保持连接状态，所以当请求地址的DNS发生更新的时候并不会应用到这个Http连接上。这个问题在微服务，高可用时代更加常见<a href=\"https://github.com/dotnet/corefx/issues/11224\">Singeton HttpClient doesn\'t respect DNS changes</a>。</p> \n<p>最终，一个叫做<a href=\"https://github.com/aspnet/HttpClientFactory\">HttpClientFactory</a>的开源实现用来彻底解决这个问题。微软也将HttpClientFactory集成在了.NET Core中。</p> \n<h2 id=\"在.net-core中创建httpclient\">在.NET Core中创建HttpClient</h2> \n<h4 id=\"添加nuget\">1.添加Nuget</h4> \n<pre><code>Microsoft.Extensions.Http </code></pre> \n<h4 id=\"在dependency-injection容器中注册服务\">2.在Dependency Injection容器中注册服务</h4> \n<pre class=\"csharp\"><code>services.AddHttpClient();</code></pre> \n<h4 id=\"使用构造器注入使用ihttpclientfactory\">3. 使用构造器注入使用IhttpClientFactory</h4> \n<pre class=\"csharp\"><code>public class BasicUsage\n{\n    private readonly IHttpClientFactory _clientFactory;\n\n    public BasicUsage(IHttpClientFactory clientFactory)\n    {\n        _clientFactory = clientFactory;\n    }\n\n    public async Task SendRequest()\n    {\n        var request = new HttpRequestMessage(HttpMethod.Get, \n            \"http://www.baidu.com\");\n\n        var client = _clientFactory.CreateClient();\n        var response = await client.SendAsync(request);\n        //do something for response\n    }\n}</code></pre> \n<h4 id=\"使用named-httpclient\">4. 使用Named HttpClient</h4> \n<p>由于我们在DI容器中注册了唯一的HttpClientFactory，意味着通过HttpClientFactory创建出来的HttpClient可能是同一个配置和参数，如果你需要不同配置的HttpClient，你可以通过“起名字的”的方式注册不同的HttpClient。</p> \n<pre class=\"csharp\"><code>services.AddHttpClient(\"baidu\", c =&gt;\n{\n    c.BaseAddress = new Uri(\"https://www.baidu.com\");\n    c.DefaultRequestHeaders.Add(\"Accept\", \"application/json\");\n});</code></pre> \n<p>一旦注册了一个名叫“baidu\"的HttpClient，你就可以通过下面的方式来建创建HttpClient：</p> \n<pre class=\"csharp\"><code>var client = _clientFactory.CreateClient(\"baidu\");</code></pre> \n<h4 id=\"集成polly\">5.集成Polly</h4> \n<p><a href=\"https://github.com/App-vNext/Polly\">Polly</a>是一个用来故障处理库，它允许开发者在Http请求中添加“重试、熔断器、超时等”策略。<br> 先添加Nuget:</p> \n<pre><code>Microsoft.Extensions.Http.Polly </code></pre> \n<p>添加策略：</p> \n<pre><code>var timeout = Policy.TimeoutAsync&lt;HttpResponseMessage&gt;(TimeSpan.FromSeconds(10));\n\nservices.AddHttpClient(\"baidu\")\n    .AddPolicyHandler(request =&gt; timeout)\n    .AddTransientHttpErrorPolicy(p=&gt;p.RetryAsync(3));</code></pre> \n<p>当然还有一些高阶用法，详见<a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests?view=aspnetcore-2.1\">Initiate HTTP requests</a>，总之HttpClientFactory提供了一种高效实用HttpClient的方式，如果你还在自己new HttpClient，请赶快试试新的方案吧。</p>', '2019-01-03 17:06:31', 'https://www.cnblogs.com/xiandnc/p/10215187.html');
INSERT INTO `t_blog` VALUES ('5', '为什么道理我都懂，却仍过不好一生 | 认知突破', '<p><strong>每个人都有证实偏差</strong></p> \n<p>&nbsp;</p> \n<p>简单来说就是，当你的头脑中预设立场或当你倾向于得到某个结果时，你就更容易在搜寻证据的途中不知不觉偏离公平。而我们之所以没有发现，是因为我们更喜欢自我创造的那个自己。</p> \n<p>&nbsp;</p> \n<p><strong>认清真实的自己</strong></p> \n<p>&nbsp;</p> \n<p>我们对自己的认识是由内而外还是建立在他人的反馈之上呢？别人都说的不一定是真的，因为我们会刻意迎合他人的看法而强化自己的形象。从而让大脑以为我们确实是这样。想想我们为什么要依赖别人的评价，或者致力于满足他人的期待？这种取悦并不是为了别人，而是为了自己，无非是为了让自己对自己更加满意。当你常常看到真实的自己，并接受自己时，就自然没有必要活在别人的意念之中了。</p> \n<p>&nbsp;</p> \n<p><strong>道理我都懂</strong></p> \n<p><strong>&nbsp;</strong></p> \n<p>为什么懂了这么多道理，却依然过不好这一生。知理和明理还是有分别的，道理你是知道了，但是你真的懂了吗？懂不懂的标识就是有没有践行它。如果你认为它有理，你愿意学习，也就是你真实的看到它的好处，并且这个好处是你需要的，那你又怎么会不去践行呢？不去践行的原因要么是你并没有懂，要么是你并不认为它能给你你想要的，或是结果并没有那么吸引你。对一个正确的道理表现出懒惰，就是认知能力不足的体现。</p> \n<p>&nbsp;</p> \n<p><strong>没机会，真的不怪运气</strong></p> \n<p><strong>&nbsp;</strong></p> \n<p>我们要搞清楚什么是运气？我们每个人都有获得运气的能力，但是有没有运气又依赖于我们自己。机会指的是一定时间内迈向运气的可能，而我们身边从来不缺机会。机会一直在那里，只是你没有满足开启它的条件而已。</p> \n<p>&nbsp;</p> \n<p><strong>正确的获取好人缘</strong></p> \n<p>&nbsp;</p> \n<p>势利天生存在，我们会有倾向的选择和一些人相处，不跟另一些人相处。想要获得好人缘。就要想想自己有什么正面资源或是潜在资源。获得好人缘的正确方式是拥有更多的正面资源。</p> \n<p>&nbsp;</p> \n<p><strong>学习的动力</strong></p> \n<p>&nbsp;</p> \n<p>自我管理能力强的人有一个答案就是他们有清晰的学习目标并懂得行为和目标之间的关联。我们之所以懒惰，最大的原因是认知能力不足，表现在学习上就是目标不够清晰，或者并不真正了解行为跟目标之间的关联。持续学习的动力来源就是对于目标的认知。</p> \n<p>&nbsp;</p> \n<p><strong>有钱人更有道德</strong></p> \n<p><strong>&nbsp;</strong></p> \n<p>虽然道德感在每个人心目中的金钱价值各不相同。但他们都是可以量化的，影响这个量化标准高低的是一个人所受的教育，另一个是本身拥有的财富。为富不仁，难道为穷就仁了？仓禀实而知礼节，衣食足而知荣辱。</p> \n<p>&nbsp;</p> \n<p><strong>那些愚弄自己的努力</strong></p> \n<p><strong>&nbsp;</strong></p> \n<p>我们努力的成果发朋友圈有问题吗？发朋友圈这个行为本身就代表你的学习或工作动机有一定的偏差，朋友圈的点赞和评论会导致我们更容易自我感动，且更容易在潜意识里驱使你将可以在白天做完的事情拖到晚上做。</p> \n<p>&nbsp;</p> \n<p><strong>操别人的闲心</strong></p> \n<p><strong>&nbsp;</strong></p> \n<p>每个人都只有这么点时间和注意力，操心别人的事情越多，自己可操心的事情就越少，于是，你会发现一个有趣的现象，越是有能能力的人，越是专注在自己的事情上面。越是在能力上已经落后的人们，越是不知道自己该操心的事情是什么。</p> \n<p>&nbsp;</p> \n<p>社交，为了达成某种目的，或是利益，或是心理上的。或是某种满足感，这些是钱买不到的。</p> \n<p>&nbsp;</p> \n<p>社交的内核，等价交换。而低价值的人总喜欢打人情牌，也是一种想占便宜的心理。所以，当我们看不清社交的内核时，我们往往是在瞎忙活。所以我们一般交往的都是与自己相符合的人群，想结识更厉害的人，首先就要提升自己的水平。</p> \n<p>&nbsp;</p> \n<p>知恩即报！当你获得了价值时，你要学会立即报答，而不是等等，因为任何恩情都会随着时间的流逝而被打上折扣。且时间越长，折扣率越大。</p> \n<p>&nbsp;</p> \n<p>人生是经历，这不是什么没有营养的鸡汤，我们永远在不停赶路，试图从一个目标到另一个目标，但其实我们人生的全部，却是在路上遇到的那些客观事物在我们脑海中的思想，记忆和情感。我们的生命里，一直都只有孤独的自己。</p> \n<p>&nbsp;</p> \n<p>每个人都希望变的更好，只要你还有欲望的话，因为变得更好在本质上也是为了得到更多。不管是物质上的，还是精神上的。别看有些人嘴上说不想努力，其实世上没有人会排斥努力后带来的好结果。排斥的是伴随着它的成本。</p> \n<p>&nbsp;</p> \n<p>人都是自利的，哪怕看起来是利他的行为也是自利的。一种是消费，一种是投资。自愿放弃当前的利益也是自利的一种行为，为了博取更长久的利益。区别就是这是投资，为了未来投资。</p> \n<p>&nbsp;</p> \n<p>幸福人人都能拥有。幸福是一个主观事物。幸福的刺激是通过比较的方式由大脑营造出来的。当然，不幸也是如此。</p> \n<p>&nbsp;</p> \n<p>我们的同情心也是自己想要幸福的一种方式，展示自己的优越感，别人可能会收益，但是首先收益的肯定是我们自己。</p> \n<p>&nbsp;</p> \n<p>幸福只源于跟他人和自己的比较之中，如果你想获得幸福感，不需要自欺欺人，只要摆正自己对幸福的认知即可。我们同他人比较，我们同自己不同的状态进行比较。</p> \n<p>&nbsp;</p> \n<p>你渴望的是什么？你就已经高估了这件事在你心中的位置。</p>', '2019-01-03 17:06:31', 'https://www.cnblogs.com/YJK923/p/10199187.html');
INSERT INTO `t_blog` VALUES ('6', 'Flex很难？一文就足够了', '<h2 id=\"flexible-box-是什么\">Flexible Box 是什么</h2> \n<p><img src=\"//upload-images.jianshu.io/upload_images/7928504-df75c02658ab0d1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480\"></p> \n<p>  布局的传统解决方案，基于<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/box_model\">盒状模型</a>，依赖&nbsp;<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/display\"><code>display</code></a>&nbsp;属性 +&nbsp;<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/position\"><code>position</code></a>属性 +&nbsp;<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/float\"><code>float</code></a>属性。它对于那些特殊布局非常不方便，比如，<a href=\"https://css-tricks.com/centering-css-complete-guide/\">垂直居中</a>就不容易实现。所以在2009年，w3c提出了一种可以简洁、快速弹性布局的属性，主要思想是给予容器控制内部元素高度和宽度的能力，这就是今天要说的Flexible Box，弹性布局。</p> \n<p>  由于浏览器的限制，在写代码之前推荐查询一下兼容模式，了解下目前flex的支持程度，我们可以通过<a href=\"https://www.caniuse.com/\">CanIuse</a>这个网站来进行查询，如下图，可以看到，除了对于IE支持一般之外，其他浏览器大多没啥毛病，但为了以防万一，在写代码的时候还是加上<code>-webkit-</code>这一前缀以防万一。</p> \n<pre class=\"css\"><code>.box{\n  display: -webkit-flex; /* Safari */\n  display: flex;\n}</code></pre> \n<p><img src=\"null2019/01/03/e91c03d2-7b0f-41a8-bd9a-200b54998596.png\"></p> \n<blockquote> \n <p>重点！flex一共有两根轴：main axis（主轴）和cross axis（交叉轴），大家一般认为主轴就是水平，交叉轴就是垂直的。但是！这是错误的！请与水平垂直这两个方位的概念区分开，这是一个方位，如果说当年定义的时侯为什么不命名为vertical&amp;horizon？？原因就是main axis没有一个固定的方位，所以请不要再通过水平垂直的方位来理解了。那么主轴是怎么区分的呢？其实很简单按照当前flex的方向，是水平排列还是垂直排列。如果是水平排列（row），主轴就是水平的，交叉轴就是垂直的，反之亦然。这是一个很重要的概念。</p> \n</blockquote> \n<p><img src=\"null2019/01/03/542e1d38-faf8-49ca-8951-ef45d5b44053.png\"></p> \n<p><font color=\"#E64A19\">注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。</font></p> \n<h2 id=\"属性描述\">属性描述</h2> \n<h3 id=\"父容器的属性\">父容器的属性</h3> \n<p><strong>flex-direction</strong> :该元素决定主轴的方向（即子元素的排列方向） 默认值 :row 适用于 :flex 容器</p> \n<table> \n <thead> \n  <tr class=\"header\"> \n   <th>属性</th> \n   <th>描述</th> \n  </tr> \n </thead> \n <tbody> \n  <tr class=\"odd\"> \n   <td>row</td> \n   <td>主轴为水平方向，起点在左端。</td> \n  </tr> \n  <tr class=\"even\"> \n   <td>row-reverse</td> \n   <td>主轴为水平方向，起点在右端。</td> \n  </tr> \n  <tr class=\"odd\"> \n   <td>column</td> \n   <td>主轴为垂直方向，起点在上沿。</td> \n  </tr> \n  <tr class=\"even\"> \n   <td>column-reverse</td> \n   <td>主轴为垂直方向，起点在下沿。</td> \n  </tr> \n </tbody> \n</table> \n<p><img src=\"null2019/01/03/809d965c-68fa-4a5b-8348-6e86ca3e0dc2.gif\"></p> \n<p><img src=\"null2019/01/03/f55e88ff-7ad7-40d3-8c2a-aad7ce4d1eca.gif\"></p> \n<p><img src=\"null2019/01/03/999ecf99-36e1-4de3-81ce-20a6b0a5473a.gif\"></p> \n<p><strong>flex-wrap</strong> :设置或检索伸缩盒对象的子元素超出父容器时是否换行 默认值 :nowrap 适用于 :flex 容器</p> \n<table> \n <thead> \n  <tr class=\"header\"> \n   <th>属性</th> \n   <th>描述</th> \n  </tr> \n </thead> \n <tbody> \n  <tr class=\"odd\"> \n   <td>nowrap</td> \n   <td>不换行(默认)</td> \n  </tr> \n  <tr class=\"even\"> \n   <td>wrap</td> \n   <td>换行，第一行在上方</td> \n  </tr> \n  <tr class=\"odd\"> \n   <td>wrap-reverse</td> \n   <td>换行，第一行在下方</td> \n  </tr> \n </tbody> \n</table> \n<p><img src=\"null2019/01/03/149f8afd-ab52-4fcf-8578-4988d49102c4.png\"></p> \n<p><em>PS: <code>flex-flow</code> 属性是 <code>flex-direction</code> 属性和 <code>flex-wrap</code> 属性的简写形式，默认值为 <code>row nowrap</code></em></p> \n<pre><code>.box {\n  flex-flow: flex-direction flex-wrap|initial|inherit;\n}</code></pre> \n<p><strong>justify-content</strong> :定义了子元素在主轴上的对齐方式。 默认值 :flex-start 适用于 :flex 容器</p> \n<table> \n <thead> \n  <tr class=\"header\"> \n   <th>属性</th> \n   <th>描述</th> \n  </tr> \n </thead> \n <tbody> \n  <tr class=\"odd\"> \n   <td>flex-start</td> \n   <td>左对齐</td> \n  </tr> \n  <tr class=\"even\"> \n   <td>flex-end</td> \n   <td>右对齐</td> \n  </tr> \n  <tr class=\"odd\"> \n   <td>center</td> \n   <td>居中</td> \n  </tr> \n  <tr class=\"even\"> \n   <td>space-between</td> \n   <td>两端对齐，项目之间的间隔都相等</td> \n  </tr> \n  <tr class=\"odd\"> \n   <td>space-around</td> \n   <td>每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</td> \n  </tr> \n </tbody> \n</table> \n<p><img src=\"null2019/01/03/cb1ff5a9-78eb-4ff8-b6f1-8a9c1c94d748.gif\"></p> \n<p><strong>align-items</strong> :定义了子元素在交叉轴上的对齐方式 默认值 :stretch 适用于 :flex 容器</p> \n<table> \n <thead> \n  <tr class=\"header\"> \n   <th>属性</th> \n   <th>描述</th> \n  </tr> \n </thead> \n <tbody> \n  <tr class=\"odd\"> \n   <td>flex-start</td> \n   <td>交叉轴的起点对齐</td> \n  </tr> \n  <tr class=\"even\"> \n   <td>flex-end</td> \n   <td>交叉轴的终点对齐</td> \n  </tr> \n  <tr class=\"odd\"> \n   <td>center</td> \n   <td>交叉轴的中点对齐</td> \n  </tr> \n  <tr class=\"even\"> \n   <td>baseline</td> \n   <td>子元素第一行文字的基线对齐,如果子标签内没有内容，将按照每个 div 的底部对齐</td> \n  </tr> \n  <tr class=\"odd\"> \n   <td>stretch</td> \n   <td>如果项目未设置高度或设为auto，将占满整个容器的高度</td> \n  </tr> \n </tbody> \n</table> \n<p><strong>align-items: stretch 时每个子元素的 height 必须为 auto 否则 height 属性会覆盖 stretch 的效果</strong></p> \n<p><img src=\"null2019/01/03/95189dc6-5926-485e-8c8f-e5eb332388b8.png\"></p> \n<p><img src=\"null2019/01/03/180c1ddd-bcbe-4cb2-888c-4759f3d324fd.gif\"></p> \n<p><strong>如果 div 内没有内容，或者子标签内没有内容，将按照每个 div 的底部对齐</strong></p> \n<p><img src=\"null2019/01/03/2493860e-8506-4b36-93e6-1299ed197e7c.png\"></p> \n<p><strong>align-content</strong> :定义多根轴线的对齐方式，如果子元素只有一根轴线，该属性不起作用 默认值 :stretch 适用于 :多行的弹性盒模型容器</p> \n<table> \n <thead> \n  <tr class=\"header\"> \n   <th>属性</th> \n   <th>描述</th> \n  </tr> \n </thead> \n <tbody> \n  <tr class=\"odd\"> \n   <td>flex-start</td> \n   <td>与交叉轴的起点对齐</td> \n  </tr> \n  <tr class=\"even\"> \n   <td>flex-end</td> \n   <td>与交叉轴的终点对齐</td> \n  </tr> \n  <tr class=\"odd\"> \n   <td>center</td> \n   <td>与交叉轴的中点对齐</td> \n  </tr> \n  <tr class=\"even\"> \n   <td>space-between</td> \n   <td>与交叉轴两端对齐，轴线之间的间隔平均分布</td> \n  </tr> \n  <tr class=\"odd\"> \n   <td>space-around</td> \n   <td>每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</td> \n  </tr> \n  <tr class=\"even\"> \n   <td>stretch</td> \n   <td>轴线占满整个交叉轴</td> \n  </tr> \n </tbody> \n</table> \n<p><img src=\"null2019/01/03/6f209497-558e-4964-bd7e-0b31e95a2566.png\"></p> \n<p><em>PS: 在上面的例子 <strong>flex-wrap</strong> 需设为 <strong>wrap</strong>, 且数量超出一行, 父容器的高度相对于子容器有多余，才能看到效果</em></p> \n<h3 id=\"子元素的属性\">子元素的属性</h3> \n<p><strong>order</strong> :定义子元素的排列顺序，数值越小，排列越靠前 默认值:0 适用于:flex子项和flex容器中的绝对定位子元素</p> \n<p><img src=\"null2019/01/03/62a2bbdc-0522-40f2-b8a4-fd68f4ced0e6.png\"></p> \n<p><em>PS：用整数值来定义排列顺序，数值小的排在前面。元素的值可以为负值</em></p> \n<p><strong>flex-grow</strong> :定义子元素的放大比例 默认值 :0 适用于 :flex子项</p> \n<pre class=\"html\"><code>&lt;ul class=\"flex\"&gt;\n  &lt;li&gt;a&lt;/li&gt;\n  &lt;li&gt;b&lt;/li&gt;\n  &lt;li&gt;c&lt;/li&gt;\n&lt;/ul&gt;</code></pre> \n<pre class=\"css\"><code>.flex{display:flex;width:600px;margin:0;padding:0;list-style:none;}\n.flex li {text-align:center;height:100px;}\n.flex li:nth-child(1){width:200px;background-color:green;}\n.flex li:nth-child(2){flex-grow:1;width:50px;background-color:yellow;}\n.flex li:nth-child(3){flex-grow:3;width:50px;background-color:red;}</code></pre> \n<p>flex-grow的默认值为0，如果没有显示定义该属性，是不会拥有分配剩余空间权利的。<br> 本例中b,c两项都显式的定义了flex-grow，flex容器的剩余空间分成了4份，其中b占1份，c占3分，即1:3<br> flex容器的剩余空间长度为：600-200-50-50=300px，所以最终a,b,c的长度分别为：<br> a: 50+(300/4)=200px<br> b: 50+(300/4<em>1)=125px<br> c: 50+(300/4</em>3)=275px</p> \n<p><img src=\"null2019/01/03/ecd154d3-76c5-47c9-bfbb-180e06807b8a.gif\"></p> \n<p><img src=\"null2019/01/03/099175da-8055-4769-8515-5f26bfa2894c.gif\"></p> \n<p><strong>flex-shrink</strong> :定义子元素的收缩比例（与flex-grow相反） 默认值 :1 适用于 :flex子项</p> \n<pre class=\"html\"><code>&lt;ul class=\"flex\"&gt;\n  &lt;li&gt;a&lt;/li&gt;\n  &lt;li&gt;b&lt;/li&gt;\n  &lt;li&gt;c&lt;/li&gt;\n&lt;/ul&gt;</code></pre> \n<pre class=\"css\"><code>.flex{display:-webkit-flex;display:flex;width:400px;margin:0;padding:0;list-style:none;}\n.flex li{width:200px;}\n.flex li:nth-child(1){background:#888;}\n.flex li:nth-child(2){background:#ccc;}\n.flex li:nth-child(3){-webkit-flex-shrink:3;flex-shrink:3;background:#aaa;}</code></pre> \n<p>flex-shrink的默认值为1，如果没有显示定义该属性，将会自动按照默认值1在所有因子相加之后计算比率来进行空间收缩。<br> 本例中c显式的定义了flex-shrink，a,b没有显式定义，但将根据默认值1来计算，可以看到总共将剩余空间分成了5份，其中a占1份，b占1份，c占3分，即1:1:3<br> 我们可以看到父容器定义为400px，子项被定义为200px，相加之后即为600px，超出父容器200px。那么这么超出的200px需要被a,b,c消化<br> 通过收缩因子，所以加权综合可得200<em>1+200</em>1+200<em>3=1000px；<br> 于是我们可以计算a,b,c将被移除的溢出量是多少：<br> a被移除溢出量：(200</em>1/1000)<em>200，即约等于40px<br> b被移除溢出量：(200</em>1/1000)<em>200，即约等于40px<br> c被移除溢出量：(200</em>3/1000)*200，即约等于120px<br> 最后a,b,c的实际宽度分别为：200-40=160px, 200-40=160px, 200-120=80px</p> \n<p><img src=\"null2019/01/03/f6e5b432-b2ac-4e37-b213-cf3decb49632.gif\"></p> \n<p><img src=\"null2019/01/03/11cae782-f1d4-40a3-b831-67703bc9d1bd.gif\"></p> \n<p><img src=\"null2019/01/03/c2fc0b04-9002-4a1b-9bdb-dd5e170ebcb0.gif\"></p> \n<p>PS:如果所有项目的 <strong>flex-shrink</strong> 属性都为 <strong>1</strong>，当空间不足时，都将等比例缩小。如果一个项目的 <strong>flex-shrink</strong> 属性为<strong>0</strong>，其他项目都为 <strong>1</strong>，则空间不足时，前者不缩小。负值对该属性无效。</p> \n<p><strong>flex-basis</strong> :设置或检索弹性盒伸缩基准值 默认值 :auto 适用于 :flex子项</p> \n<p><img src=\"null2019/01/03/b310514a-e577-4e82-80e7-f5d42b45d4e2.png\"></p> \n<p><em>flex-basis 控制元素的默认尺寸，然后再由其他 Flexbox 属性控制，可以覆盖 width 属性</em></p> \n<p><strong>flex-basis 可以和 width 属性互换</strong></p> \n<p><img src=\"null2019/01/03/fa08e746-a28e-4f59-ad8d-a534f1fa0ad5.gif\"></p> \n<p><strong>PS:flex-basis 是通过主轴 (main axis) 来影响元素尺寸的</strong></p> \n<p><img src=\"null2019/01/03/d4a5612d-a2a4-4e59-84d8-3f48188cddd3.gif\"></p> \n<p><strong>align-self</strong>:允许单个子元素有与其他项目不一样的对齐方式，可覆盖align-items属性 默认值 :auto 适用于 :flex子项</p> \n<table> \n <thead> \n  <tr class=\"header\"> \n   <th>属性</th> \n   <th>描述</th> \n  </tr> \n </thead> \n <tbody> \n  <tr class=\"odd\"> \n   <td>auto</td> \n   <td>继承父元素的\"align-items\"值，如果其没有父元素，等同于\"stretch\"</td> \n  </tr> \n  <tr class=\"even\"> \n   <td>flex-start</td> \n   <td>交叉轴的起点对齐</td> \n  </tr> \n  <tr class=\"odd\"> \n   <td>flex-end</td> \n   <td>交叉轴的终点对齐</td> \n  </tr> \n  <tr class=\"even\"> \n   <td>center</td> \n   <td>交叉轴的中点对齐</td> \n  </tr> \n  <tr class=\"odd\"> \n   <td>baseline</td> \n   <td>第一行文字的基线对齐</td> \n  </tr> \n  <tr class=\"even\"> \n   <td>stretch</td> \n   <td>如果项目未设置高度或设为auto，将占满整个容器的高度</td> \n  </tr> \n </tbody> \n</table> \n<p><strong>父元素: align-items:flex-end</strong><br> a: align-self: flex-end<br> b: align-self: center<br> c: align-self: flex-start<br> d: align-self: baseline; padding: 20px 10px<br> e: align-self: baseline<br> f: align-self: stretch<br> g: align-self: auto</p> \n<p><img src=\"null2019/01/03/6c481382-3d3d-4547-bdf3-1a7afa8ee0ae.png\"></p> \n<p><img src=\"null2019/01/03/80ec77d4-31fa-45d2-a37e-cc1d9d382855.gif\"></p> \n<h2 id=\"参考\">参考</h2> \n<ol> \n <li><a href=\"http://css.doyoe.com/\">CSS参考手册</a></li> \n <li><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\">Flex 布局教程-阮一峰</a></li> \n <li><a href=\"https://medium.freecodecamp.org/even-more-about-how-flexbox-works-explained-in-big-colorful-animated-gifs-a5a74812b053\">Even more about how Flexbox works — explained in big, colorful, animated gifs</a></li> \n <li><a href=\"https://medium.freecodecamp.org/an-animated-guide-to-flexbox-d280cf6afc35\">How Flexbox works — explained with big, colorful, animated gifs</a></li> \n</ol>', '2019-01-03 17:07:00', 'https://www.cnblogs.com/linwene/p/10215142.html');
INSERT INTO `t_blog` VALUES ('7', 'testNG-失败用例重跑机制', '<p>下面简单介绍下testNG的失败重跑的实现方法：</p> \n<p>1.首先编写一个类，实现IRetryAnalyzer类，重写其中的retry方法。</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: #0000ff\">public</span> <span style=\"color: #0000ff\">class</span> TestNGRetry <span style=\"color: #0000ff\">implements</span><span style=\"color: #000000\"> IRetryAnalyzer {\n\n    </span><span style=\"color: #0000ff\">private</span> <span style=\"color: #0000ff\">int</span> retryCount = 1<span style=\"color: #000000\">;//设置当前的重跑次数\n    </span><span style=\"color: #0000ff\">private</span> <span style=\"color: #0000ff\">static</span> <span style=\"color: #0000ff\">final</span> <span style=\"color: #0000ff\">int</span> maxRetryCount = 3<span style=\"color: #000000\">;//设置最大重跑次数，定义为常量。\n\n    @Override\n    </span><span style=\"color: #0000ff\">public</span> <span style=\"color: #0000ff\">boolean</span><span style=\"color: #000000\"> retry(ITestResult iTestResult) {\n        </span><span style=\"color: #0000ff\">if</span> (retryCount&lt;=<span style=\"color: #000000\">maxRetryCount){\n            System.out.println(</span>\"it\'s the \"+retryCount+\"times retry.And the current case is\"+<span style=\"color: #000000\">iTestResult.getName());//输出当前的重跑次数以及当前的正在重跑的用例名称。\n\n            retryCount</span>++<span style=\"color: #000000\">;//重跑之后，次数+1\n            </span><span style=\"color: #0000ff\">return</span> <span style=\"color: #0000ff\">true</span><span style=\"color: #000000\">;//当return true之后，代表继续重跑\n        }\n        </span><span style=\"color: #0000ff\">return</span> <span style=\"color: #0000ff\">false</span><span style=\"color: #000000\">;//return false之后，代表停止重跑\n    }\n\n    </span><span style=\"color: #0000ff\">public</span> <span style=\"color: #0000ff\">void</span><span style=\"color: #000000\"> reSetCount(){\n        retryCount</span>=1<span style=\"color: #000000\">;\n    }\n\n}</span></pre> \n</div> \n<p>在完成这个方法的重写之后，其实已经可以实现失败用例重跑了。前提是，用例上注解设置如下：</p> \n<div class=\"cnblogs_code\"> \n <pre>@Test(retryAnalyzer= TestNGRetry.<span style=\"color: #0000ff\">class</span>)</pre> \n</div> \n<pre>当然，我们是期望所有的用例执行失败之后，都可以重跑，所以就需要考虑执行时动态修改我们用例的注解。testNG已经给实现了，我们只</pre> \n<pre>需要编写一个类去实现IAnnotationTransformer，并重写方法transform</pre> \n<pre></pre> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: #0000ff\">public</span> <span style=\"color: #0000ff\">class</span> RetryListener <span style=\"color: #0000ff\">implements</span><span style=\"color: #000000\"> IAnnotationTransformer {\n    @Override\n    </span><span style=\"color: #0000ff\">public</span> <span style=\"color: #0000ff\">void</span><span style=\"color: #000000\"> transform(ITestAnnotation iTestAnnotation, Class aClass, Constructor constructor, Method method) {\n        IRetryAnalyzer retryAnalyzer </span>=<span style=\"color: #000000\"> iTestAnnotation.getRetryAnalyzer();//获取到retryAnalyzer的注解</span></pre> \n <pre><span style=\"color: #0000ff\">if</span> (retryAnalyzer == <span style=\"color: #0000ff\">null</span><span style=\"color: #000000\">){ iTestAnnotation.setRetryAnalyzer(TestNGRetry.</span><span style=\"color: #0000ff\">class</span><span style=\"color: #000000\">); } } }//如果注解为空，则动态设置注解，以确保用例失败后重跑。</span></pre> \n</div> \n<p>&nbsp;</p> \n<pre>在testNG的xml配置文件中配置上述监听器：</pre> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: #0000ff\">&lt;?</span><span style=\"color: #ff00ff\">xml version=\"1.0\" encoding=\"UTF-8\"</span><span style=\"color: #0000ff\">?&gt;</span>\n<span style=\"color: #0000ff\">&lt;!</span><span style=\"color: #ff00ff\">DOCTYPE suite SYSTEM \"http://testng.org/testng-1.0.dtd\"</span><span style=\"color: #0000ff\">&gt;</span>\n<span style=\"color: #0000ff\">&lt;</span><span style=\"color: #800000\">suite </span><span style=\"color: #ff0000\">name</span><span style=\"color: #0000ff\">=\"NeuronIOSSystemTest\"</span><span style=\"color: #ff0000\"> parallel</span><span style=\"color: #0000ff\">=\"true\"</span><span style=\"color: #ff0000\">\n    thread-count</span><span style=\"color: #0000ff\">=\"2\"</span><span style=\"color: #0000ff\">&gt;</span>\n    <span style=\"color: #0000ff\">&lt;</span><span style=\"color: #800000\">listeners</span><span style=\"color: #0000ff\">&gt;</span>\n        <span style=\"color: #0000ff\">&lt;</span><span style=\"color: #800000\">listener\n            </span><span style=\"color: #ff0000\">class-name</span><span style=\"color: #0000ff\">=\"com.neuron.util.TestRunnerListener\"</span> <span style=\"color: #0000ff\">/&gt;</span>\n        <span style=\"color: #0000ff\">&lt;</span><span style=\"color: #800000\">listener </span><span style=\"color: #ff0000\">class-name</span><span style=\"color: #0000ff\">=\"com.nervos.neuron.retry.RetryListener\"</span><span style=\"color: #0000ff\">/&gt;</span>\n    <span style=\"color: #0000ff\">&lt;/</span><span style=\"color: #800000\">listeners</span><span style=\"color: #0000ff\">&gt;</span>\n\n    <span style=\"color: #0000ff\">&lt;</span><span style=\"color: #800000\">test </span><span style=\"color: #ff0000\">verbose</span><span style=\"color: #0000ff\">=\"2\"</span><span style=\"color: #ff0000\"> name</span><span style=\"color: #0000ff\">=\"Neuron iOS App System Test\"</span><span style=\"color: #ff0000\">\n        preserve-order</span><span style=\"color: #0000ff\">=\"true\"</span><span style=\"color: #ff0000\"> enabled</span><span style=\"color: #0000ff\">=\"true\"</span><span style=\"color: #0000ff\">&gt;</span>\n        <span style=\"color: #0000ff\">&lt;</span><span style=\"color: #800000\">classes</span><span style=\"color: #0000ff\">&gt;</span>\n            <span style=\"color: #0000ff\">&lt;</span><span style=\"color: #800000\">class </span><span style=\"color: #ff0000\">name</span><span style=\"color: #0000ff\">=\"com.xxx.xxx.xxxTest\"</span> <span style=\"color: #0000ff\">/&gt;</span>\n            \n        <span style=\"color: #0000ff\">&lt;/</span><span style=\"color: #800000\">classes</span><span style=\"color: #0000ff\">&gt;</span>\n    <span style=\"color: #0000ff\">&lt;/</span><span style=\"color: #800000\">test</span><span style=\"color: #0000ff\">&gt;</span>\n<span style=\"color: #0000ff\">&lt;/</span><span style=\"color: #800000\">suite</span><span style=\"color: #0000ff\">&gt;</span></pre> \n</div> \n<p>&nbsp;</p> \n<p>综上，失败用例重跑机制基本实现。但是在执行的时候，会发现一个问题：</p> \n<p>使用了dataProvider并且提供多个数据的时候，这个重跑次数是共用的，就会导致dataProvider提供的第一个数据执行失败后，重跑3次。如果提供的第二个数据再次失败了，就不会再重跑了。</p> \n<p>或者dataProvider提供的第一个数据执行失败后，重跑第一次的时候又成功了。提供的第二个数据再次失败了，就只重跑2次。</p> \n<p>所以，在用例执行失败和用例执行成功后，都需要重置当前的重跑次数。</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: #0000ff\">public</span> <span style=\"color: #0000ff\">class</span> TestRunnerListener <span style=\"color: #0000ff\">extends</span><span style=\"color: #000000\"> TestListenerAdapter {\n    @Override\n    </span><span style=\"color: #0000ff\">public</span> <span style=\"color: #0000ff\">void</span><span style=\"color: #000000\"> onTestSuccess(ITestResult tr) {\n        TestNGRetry retryAnalyzer </span>=<span style=\"color: #000000\"> (TestNGRetry) tr.getMethod().getRetryAnalyzer();\n</span><span style=\"color: #000000\">        retryAnalyzer.reSetCount();\n        finish(tr);\n    }\n\n\n    @Override\n    </span><span style=\"color: #0000ff\">public</span> <span style=\"color: #0000ff\">void</span><span style=\"color: #000000\"> onTestFailure(ITestResult tr) {\n　　　　　TestNGRetry retryAnalyzer </span>=<span style=\"color: #000000\"> (TestNGRetry) tr.getMethod().getRetryAnalyzer();\n</span><span style=\"color: #000000\">        retryAnalyzer.reSetCount();\n        finish(tr);\n    }\n}</span></pre> \n</div> \n<p>&nbsp;</p> \n<p>以上，完全实现了失败用例的重跑机制。</p> \n<p>&nbsp;</p> \n<p>&nbsp;</p> \n<pre><br><br><br></pre>', '2019-01-03 17:07:00', 'https://www.cnblogs.com/clairejing/p/10215054.html');
INSERT INTO `t_blog` VALUES ('8', '学习T-io框架，从写一个Redis客户端开始', '<h2 id=\"前言\">前言</h2> \n<p>&nbsp;&nbsp;了解<code>T-io</code>框架有些日子了，并且还将它应用于实战，例如 <code>tio-websocket-server</code>,<code>tio-http-server</code>等。但是由于上述两个<code>server</code>已经封装好，直接应用就可以。所以对于整个数据流通的过程不是很明朗，甚至对于<code>hello-world</code>例子中的<code>encode</code>,<code>decode</code>作用并不理解。于是乎想写一个更贴近实际应用的<code>redis-client</code>来作为学习切入点，虽然编码过程中困难重重，不过最后还是实现了一个粗糙的客户端。由于代码中大量参考了<code>Jedis</code>源码，所以，我给这个客户端起名<code>T-io</code>+<code>Redis</code>=<code>Tedis</code>.哈哈，这些都不重要，下文中将会记录出我的学习和开发历程。</p> \n<h2 id=\"redis通信协议\">Redis通信协议</h2> \n<p>&nbsp;&nbsp;<a href=\"https://redis.io/topics/protocol\">Redis Protocol</a></p> \n<p>&nbsp;&nbsp;在开发之前，首先要去了解客户端和服务端的通信协议，那么我们开发<code>Redis</code>客户端，就要去看看Redis协议了。所以，下面要做的就是：</p> \n<ul> \n <li>明确客户端发送给服务端的消息格式</li> \n <li>明确服务端返回给客户端的消息格式<br> 在此呢，我只简单举一个 <code>GET</code>,<code>SET</code>的例子，其他的内容大家可以去看参考文档。</li> \n</ul> \n<pre><code>//SET命令\nset mykey myvalue\n//GET命令\nget mykey</code></pre> \n<p>上述两个简单的命令，根据<code>Redis</code>协议可以解析成如下内容</p> \n<pre><code>//SET命令\n*3\\r\\n$3\\r\\nset\\r\\n$5\\r\\nmykey\\r\\n$7\\r\\nmyvalue\\r\\n\n//GET命令\n*2\\r\\n$3\\r\\nget\\r\\n$5\\r\\nmykey\\r\\n</code></pre> \n<p>其中 <code>*3</code>代表有三段内容，即 <code>SET</code>,<code>mykey</code>,<code>myvalue</code>.每一段内容之间由 <code>CRLF（\\r\\n）</code>隔开.<code>$</code>符号后边跟的数字就是数据字节数。引用官方的一个图：<br> <img src=\"null2019/01/03/98b4724d-d61d-4e0c-976c-78b8b9ecdd9d.png\"><br> 在<code>Jedis</code>源码中，对于消息体的构造比较麻烦，我看的也是云里雾里的，所以在<code>Tedis</code>的实现中我才用了最简单的拼接方式。即<code>StringBuilder</code>根据规则拼接字符串，然后调用<code>getBytes</code>方法获取<code>byte[]</code>。示例代码如下：</p> \n<pre><code>public static byte[] buildCommandBody(final ProtocolCommand cmd,String... args) {\n        StringBuilder builder = new StringBuilder();\n        //*[num]\n        builder.append(\'*\')\n                //命令数（1） + 参数的个数\n                .append(1 + args.length);\n        appendCrLf(builder)\n                //命令长度  $[cmd_length]\n                .append(\"$\")\n\n                .append(cmd.getName().length());\n        appendCrLf(builder)\n                //命令内容 cmd\n                .append(cmd.getName());\n        appendCrLf(builder);\n\n        //遍历参数，按照 $[num]\\r\\n[content]\\r\\n的格式拼接\n        for (String arg : args) {\n            builder.append(\"$\")\n                    .append(arg.length());\n            appendCrLf(builder)\n                    .append(arg);\n            appendCrLf(builder);\n        }\n        //最后转换为 byte[],此处使用  Jedis 中的 SafeEncoder\n        return SafeEncoder.encode(builder.toString());\n\n    }</code></pre> \n<p>调用示例：</p> \n<pre><code> public static void main(String[] args){\n        Protocol.buildCommandBody(Protocol.Command.SET,\"key\",\"value\");\n  }</code></pre> \n<p>打印结果：</p> \n<pre><code>*3\n$3\nSET\n$3\nkey\n$5\nvalue</code></pre> \n<p>&nbsp;&nbsp;那么到此为止，我们已经了解了如何构造发送给服务端的消息，那么如何解析服务端返回的消息呢？<br> Redis 命令会返回多种不同类型的回复。<br> 通过检查服务器发回数据的第一个字节， 可以确定这个回复是什么类型：</p> \n<ul> \n <li>状态回复（status reply）的第一个字节是 \"+\"</li> \n <li>错误回复（error reply）的第一个字节是 \"-\"</li> \n <li>整数回复（integer reply）的第一个字节是 \":\"</li> \n <li>批量回复（bulk reply）的第一个字节是 \"$\"</li> \n <li>多条批量回复（multi bulk reply）的第一个字节是 \"*\"<br> &nbsp;&nbsp;时间有限，我也只是完成了状态回复和批量回复的部分功能，下文中将以这两种回复作为讲解示例。</li> \n</ul> \n<h2 id=\"t-io登场\">T-io登场</h2> \n<p>&nbsp;&nbsp;由于只是客户端的开发，所以这里我们只会用到<code>TioClient</code>。所以，我们先把<code>Redis-Server</code>连接上。<code>ClientAioHandler</code>,<code>ClientAioListener</code>,<code>ClientGroupContext</code>自然是少不了的啦,直接上代码吧。</p> \n<ul> \n <li>初始化一个 <code>ServerNode</code></li> \n</ul> \n<pre><code> Node serverNode = new Node(\"127.0.0.1\",6379);</code></pre> \n<ul> \n <li>初始化一个<code>ClientGroupContext</code>,它依赖于<code>ClientAioHandler</code>,<code>ClientAioListener</code></li> \n</ul> \n<pre><code> ClientGroupContext clientGroupContext = new ClientGroupContext(tioClientHandler, aioListener, null);</code></pre> \n<ul> \n <li>初始化一个<code>TioClient</code></li> \n</ul> \n<pre><code> TioClient tioClient = new TioClient(clientGroupContext);</code></pre> \n<ul> \n <li>最后连接服务器，如果没有什么异常打印的话，就连接成功啦</li> \n</ul> \n<pre><code>//返回的ClientChannelContext 用于发送消息使用\nClientChannelContext clientChannelContext = tioClient.connect(serverNode);</code></pre> \n<p>&nbsp;&nbsp;恭喜你，一个<code>Redis</code>客户端宝宝就此诞生，只不过它还不会说话。结合上文协议部分的内容，我们发送一条消息给服务器。首先定义消息包：</p> \n<pre><code>public class TedisPacket extends Packet {\n    private byte[] body;\n    //getter setter\n}</code></pre> \n<p>然后调用<code>Tio.send</code>方法就可以啦。</p> \n<pre><code>     Tio.send(clientChannelContext, packet);</code></pre> \n<p>如果你已经看懂了上半部分，那么你就会知道这里 <code>TedisPacket</code>中的<code>body</code>的值就是通过<code>Protocol.buildCommandBody(Protocol.Command.SET,\"key\",\"value\");</code>来生成的。不要忘了 `ClientAioHandler.encode’方法哦。</p> \n<pre><code> @Override\n    public ByteBuffer encode(Packet packet, GroupContext groupContext, ChannelContext channelContext) {\n        TedisPacket tedisPacket = (TedisPacket) packet;\n        byte[] body = tedisPacket.getBody();\n        int bodyLen = 0;\n        if (body != null) {\n            bodyLen = body.length;\n        }\n        //只是简单将 body 放入 ByteBuffer 。\n        ByteBuffer buffer = ByteBuffer.allocate(bodyLen);\n        buffer.put(body);\n        return buffer;\n    }</code></pre> \n<p>到此为止，客户端向服务器发送消息的内容已经写完了。下面将介绍如何解析服务端的响应。</p> \n<p>&nbsp;&nbsp;当服务器正常，并且发送到服务器的消息格式符合<code>RESP</code>协议的话，那么服务器会返回你相应的内容，比如我们发送<code>SET</code>命令，服务器的正常响应是<code>+OK\\r\\n</code>.下面我们看<code>ClientAioHandler.decode</code>方法。当我批量向服务器发送消息时，服务器给我的响应也是批量接收到的。打印结果如下：<br> <img src=\"null2019/01/03/12e940a8-cdb4-4a66-94a8-afbd8fc426ce.png\"><br> 那么问题来了，我们只想要每一次发送对应一个<code>OK</code>.所以，原谅我这个菜鸟，我才明白<code>decode</code>方法的目的。那么，我们就去解析这个内容。解析过程有几个需要关注的地方：</p> \n<ul> \n <li>遇到第一个 <code>\\r</code>的时候，下一个字节一定是\'\\n\'否则，作为解析失败处理。</li> \n <li><code>\\r\\n</code>之后停止本轮解析，返回解析结果。<br> 基于上述注意事项，解析代码如下：（应该会有更优秀的方法）<br> 先获取第一个字节，它应该是 <code>+ - $ : *</code>的其中一个，如果不是的话，说明消息可能是上一次不完整导致的，等待下次解析。</li> \n</ul> \n<pre><code>byte first = buffer.get();</code></pre> \n<p>以 <code>+OK\\r\\n</code>举例：</p> \n<pre><code> private TedisPacket readSingleLinePacket(ByteBuffer buffer,int limit,int position) throws AioDecodeException {\n        byte[] body = new byte[limit - position];\n        int i = 0;\n        //结束标志\n        boolean endFlag = false;\n\n        while (buffer.position() &lt;= limit) {\n            byte b = buffer.get();\n            //如果是\\r\n            if (BufferReader.isCr(b)) {\n                byte c = buffer.get();\n                //如果不是\\n抛出异常\n                if (!BufferReader.isLf(c)) {\n                    throw new AioDecodeException(\"unexpected redis server response\");\n                }\n                //结束解析\n                endFlag = true;\n                break;\n            } else {\n                body[i++] = b;\n            }\n        }\n        //如果此次解析一直没有遇到\\r\\n，则返回null，等待下次解析\n        if (!endFlag) {\n            return null;\n        }\n        TedisPacket packet = new TedisPacket();\n        packet.setBody(body);\n        return packet;\n    }</code></pre> \n<p>写完解析代码之后，再一次调试结果如下，可以看到数据以5个字节减少，说明数据包被正确解析了。打印内容来自<code>Tio:DecodeRunnable.java</code>.<br> <img src=\"null2019/01/03/b4501562-8c4f-4f50-8b16-5a260f6357aa.png\"><br> 到此为止，我们完成了消息的发送和接收，但是问题来了，由于消息是异步接收，那我们如何才能让客户端知道命令调用是否成功呢？<font color=\"#A52A2A\">注意，下文中的内容仅为个人理解，错误之处恳请指正</font><br> 既然redis是单线程处理的，那么我是否可以理解为，消息的处理就是先到先处理，后到后处理呢？所以，我的解决方式是通过 <code>LinkedBlockingQueue</code>。当解析完一个包之后，将这个包放入阻塞队列中。</p> \n<pre><code> @Override\n    public void handler(Packet packet, ChannelContext channelContext) throws Exception {\n        TedisPacket responsePacket = (TedisPacket) packet;\n        if (responsePacket != null) {\n            QueueFactory.get(clientName).put(responsePacket);\n        }\n    }</code></pre> \n<p>同步接收返回消息：</p> \n<pre><code>   private String getReponse() {\n        for (; ; ) {\n            try {\n                TedisPacket packet = QueueFactory.get(clientName).take();\n                return packet.hasBody() ? SafeEncoder.encode(packet.getBody()) : null;\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n    }</code></pre> \n<p>所以set代码就变成这样：</p> \n<pre><code>  @Override\n    public String set(String key, String value) {\n       client.set(key,value);\n       return client.getStatusCodeReply();\n    }</code></pre> \n<p>OK,消息接收这块是基于我的理解，我也不知道对不对，而且，其中的BUG肯定也是多的数不胜数，没关系，抱着学习的心态慢慢去完善就好了。<code>Jedis</code>也不是一次两次就写成的对吧。</p> \n<h2 id=\"tedis-与-jedis\">Tedis 与 Jedis</h2> \n<p>&nbsp;&nbsp;在开发过程中，我阅读了很多<code>Jedis</code>的源代码，大体思路能看懂，可是很多细节处理对我来说就比较难了，大神的代码只可膜拜。不过也给了我很多启发。最后不知天高地厚的和人家做一下对比吧。</p> \n<pre><code> public static void main(String[] args) {\n\n        Jedis tedis = new Jedis(\"192.168.1.225\", 6379);\n        long start = SystemTimer.currentTimeMillis();\n        for (int i = 0; i &lt; 200; i++) {\n            tedis.set(\"tedis\", \"tedis\");\n        }\n        tedis.get(\"tedis\");\n        long end = SystemTimer.currentTimeMillis();\n\n        System.out.println(\"总共用时：\" + (end - start) + \"ms,平均用时：\" + ((end - start) / 100) + \"ms\");\n    }</code></pre> \n<p>Jedis结果：总共用时：262ms,平均用时：2ms<br> Tedis结果：总共用时：390ms,平均用时：3ms</p> \n<p>那么这一毫秒差在哪里呢？</p> \n<h2 id=\"总结\">总结</h2> \n<p>&nbsp;&nbsp;一篇博客简单介绍了<code>Redis</code>客户端的开发过程，当然对于成熟的客户端<code>Jedis</code>来说，也就是一个HelloWorld，不过这有什么关系呢？知其然，更要知其所以然。看了大神的代码才知道自己有多渺小哦。继续加油~~</p> \n<h6 id=\"源码地址httpsgithub.comfanpan26tedis\"><a href=\"https://github.com/fanpan26/tedis\">源码地址：https://github.com/fanpan26/tedis</a></h6>', '2019-01-03 17:07:20', 'https://www.cnblogs.com/panzi/p/10213821.html');
INSERT INTO `t_blog` VALUES ('9', 'Flask框架踩坑之ajax跨域请求', '<h3>业务场景：</h3> \n<p>前后端分离需要对接数据接口。</p> \n<p>接口测试是在postman做的，今天才开始和前端对接，由于这是我第一次做后端接口开发（第一次嘛，问题比较多）所以在此记录分享我的踩坑之旅，以便能更好的理解，应用。</p> \n<h3>问题：</h3> \n<p>前端ajax请求后端接口出现跨域问题，如下图。</p> \n<p><img src=\"null2019/01/03/0ba5ede9-df8f-4789-9650-4091c6bfbe36.png\" alt=\"\">&nbsp;</p> \n<p>翻译：因为响应头没有\"Access-Control-Allow-Origin\"，所以接口拒绝把数据返回给前端。</p> \n<h3>什么是Access-Control-Allow-Origin?</h3> \n<p>Access-Control-Allow-Origin是HTML5中定义的一种解决资源跨域的策略。</p> \n<p>浏览器只允许请求当前域的资源，而对其他域的资源表示不信任。那怎么才算跨域呢？</p> \n<ul> \n <li>请求协议<code>http,https</code>的不同</li> \n <li>域<code>domain</code>的不同</li> \n <li>端口<code>port</code>的不同</li> \n</ul> \n<p>其实说简单点,跨域，指的就是浏览器不能执行其他网站的脚本。它是由浏览器的<strong>同源策略</strong>造成的，是浏览器施加的安全限制。</p> \n<p>同源是指：协议相同，域名相同，端口相同。三者同时成立才能叫同源。</p> \n<p>浏览器的同源策略从它诞生的那一刻就出现了，具体是指从域名A下的一个页面（一般是通过ajax请求）获取域名B下的一个资源，是不被浏览器允许的。</p> \n<p>跨域资源共享（CORS）是浏览器提供的一种跨域协商机制，让前后端协商是否可以发出跨域请求。&nbsp;CORS添加了若干Access-controll-request-xxx 的头，给客户端声明自己的源、要使用的头部、用使用的请求方法；添加了若干Access-Controll-Allow-xxx的头，给服务端声明自己支持跨域的源、头部和方法。</p> \n<div class=\" m2\">\n &nbsp;\n</div> \n<div class=\" m2\"> \n <table class=\"border\" style=\"margin-left: 0px;\"> \n  <tbody> \n   <tr>\n    <th>URL</th>\n    <th>说明</th>\n    <th>是否允许通信</th>\n   </tr> \n   <tr> \n    <td>http://www.a.com/a.js<br>http://www.a.com/b.js</td> \n    <td>同一域名下</td> \n    <td>允许</td> \n   </tr> \n   <tr> \n    <td>http://www.a.com/lab/a.js<br>http://www.a.com/script/b.js</td> \n    <td>同一域名下不同文件夹</td> \n    <td>允许</td> \n   </tr> \n   <tr> \n    <td>http://www.a.com:8000/a.js<br>http://www.a.com/b.js</td> \n    <td>同一域名，不同端口</td> \n    <td>不允许</td> \n   </tr> \n   <tr> \n    <td>http://www.a.com/a.js<br>https://www.a.com/b.js</td> \n    <td>同一域名，不同协议</td> \n    <td>不允许</td> \n   </tr> \n   <tr> \n    <td>http://www.a.com/a.js<br>http://70.32.92.74/b.js</td> \n    <td>域名和域名对应ip</td> \n    <td>不允许</td> \n   </tr> \n   <tr> \n    <td>http://www.a.com/a.js<br>http://script.a.com/b.js</td> \n    <td>主域相同，子域不同</td> \n    <td>不允许</td> \n   </tr> \n   <tr> \n    <td>http://www.a.com/a.js<br>http://a.com/b.js</td> \n    <td>同一域名，不同二级域名（同上）</td> \n    <td>不允许（cookie这种情况下也不允许访问）</td> \n   </tr> \n   <tr> \n    <td>http://www.cnblogs.com/a.js<br>http://www.a.com/b.js</td> \n    <td>不同域名</td> \n    <td>不允许</td> \n   </tr> \n  </tbody> \n </table> \n</div> \n<h3>&nbsp;</h3> \n<h3>解决方案（从后端解决）</h3> \n<h4 class=\" m2\">1.后台接口允许跨域请求</h4> \n<dl class=\" m2\">\n 以Python Flask框架为例，有两种方法。\n <dt></dt>\n</dl>\n<dl class=\" m2\">\n 第一种第三方插件实现，只需要安装第三方插件就可以轻松地为所有接口添加响应头。\n</dl> \n<div class=\"cnblogs_code\"> \n <pre>pip3 install flask-cors</pre> \n</div> \n<p>&nbsp;</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: #0000ff;\">from</span> flask_cors <span style=\"color: #0000ff;\">import</span> *<span style=\"color: #000000;\">\r\n\r\napp </span>= Flask(<span style=\"color: #800080;\">__name__</span><span style=\"color: #000000;\">)\r\n<span class=\"hljs-comment\"># r\'/*\' 是通配符，让本服务器所有的URL 都允许跨域请求 <br>CORS(app, resources=<span class=\"hljs-string\">r\'/*\')</span></span><br></span></pre> \n</div> \n<h4>&nbsp;<img src=\"null2019/01/03/da442768-7997-45d3-a954-2734d24f63c6.png\" alt=\"\"></h4> \n<p>实际上就是为接口响应头添加了一个Access-Control-Allow-Origin并设置值*表示所有网站都可以请求。</p> \n<p>&nbsp;</p> \n<p>第二种接口函数自定义添加属性。</p> \n<div class=\"cnblogs_code\"> \n <pre>res.headers[<span style=\"color: #800000;\">\'</span><span style=\"color: #800000;\">Access-Control-Allow-Origin</span><span style=\"color: #800000;\">\'</span>] = <span style=\"color: #800000;\">\'</span><span style=\"color: #800000;\">*</span><span style=\"color: #800000;\">\'</span>\r\n<span style=\"color: #0000ff;\">return</span> res</pre> \n</div> \n<p>为返回结果res属性headers设置Access-Control-Allow-Origin值为*。只对当前接口有效。</p> \n<h4>2.利用nginx反向代理</h4> \n<p>&nbsp;说到nginx，不得不说真的很强大，也带来很多便利用于解决一些头疼的难题。</p> \n<p>&nbsp; 一般来说可以用来做：静态页面的服务器、静态文件缓存服务器、网站反向代理、负载均衡服务器等等，而且实现这一切，基本只需要改改那万能的配置文件即可。</p> \n<div class=\"cnblogs_code\"> \n <pre>server {\r\n        listen       80;\r\n        server_name  localhost;</pre> \n <pre>　　　　　　location / {\r\n            proxy_pass http://localhost:81;\r\n            proxy_redirect default;\r\n        }\r\n\r\n		location /apis { #添加访问目录为/apis的代理配置<br>\r\n			rewrite  ^/apis/(.*)$ /$1 break;\r\n			proxy_pass   http://localhost:82;\r\n       }</pre> \n <pre>}</pre> \n</div> \n<p>&nbsp;</p> \n<p>1.由配置信息可知，我们让nginx监听localhost的80端口，本地的81端口有都是经过localhost的80端口进行访问。</p> \n<p>2.我们特殊配置了一个“/apis”目录的访问，并且对url执行了重写，最后使以“/apis”开头的地址都转到“http://localhost:82”进行处理。</p> \n<p>3.rewrite &nbsp;^/apis/(.*)$ /$1 break，代表重写拦截进来的请求，并且只能对域名后边以“/apis”开头的起作用，例如www.a.com/apis/msg?x=1重写。只对/apis重写。rewrite后面的参数是一个简单的正则 ^/apis/(.*)$ ,$1代表正则中的第一个(),$2代表第二个()的值,以此类推。break代表匹配一个之后停止匹配。</p> \n<p>总结一下，搭建一个nginx并把相应代码部署在服务器本机，由页面请求本域名的一个地址，转由nginx代理到目标服务器处理后返回结果给页面。这样就完美解决了跨域问题。</p> \n<h3>温馨提示</h3> \n<ul> \n <li>如果您对本文有疑问，请在评论部分留言，我会在最短时间回复。</li> \n <li>如果本文帮助了您，也请评论关注，作为对我的一份鼓励。</li> \n <li>如果您感觉我写的有问题，也请批评指正，我会尽量修改。</li> \n</ul> \n<p>&nbsp;</p>', '2019-01-03 17:07:22', 'https://www.cnblogs.com/lyxdw/p/10214216.html');
INSERT INTO `t_blog` VALUES ('10', '服务器性能测试工具 ---- nmon', '<p><span style=\"font-size: 16px\"><strong>一、下载nmon</strong></span></p> \n<p>根据CPU的类型选择下载相应的版本：</p> \n<p><a href=\"http://nmon.sourceforge.net/pmwiki.php?n=Site.Download\">http://nmon.sourceforge.net/pmwiki.php?n=Site.Download</a><br>wget&nbsp;<a href=\"http://sourceforge.net/projects/nmon/files/download/nmon_x86_12a.zip/download\">http://sourceforge.net/projects/nmon/files/download/nmon_x86_12a.zip</a></p> \n<p><strong>方法1：</strong></p> \n<div class=\"cnblogs_Highlighter sh-gutter\"> \n <div> \n  <div id=\"highlighter_247858\" class=\"syntaxhighlighter  csharp\"> \n   <table style=\"height: 67px; width: 1819px\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\"> \n    <tbody> \n     <tr> \n      <td class=\"gutter\"> \n       <div class=\"line number1 index0 alt2\">\n        <span style=\"font-size: 14px\">1</span>\n       </div> \n       <div class=\"line number2 index1 alt1\">\n        <span style=\"font-size: 14px\">2</span>\n       </div> \n       <div class=\"line number3 index2 alt2\">\n        <span style=\"font-size: 14px\">3</span>\n       </div> \n       <div class=\"line number4 index3 alt1\">\n        <span style=\"font-size: 14px\">4</span>\n       </div> </td> \n      <td class=\"code\"> \n       <div class=\"container\"> \n        <div class=\"line number1 index0 alt2\">\n         <span style=\"font-size: 14px\"><code class=\"csharp plain\">[root@mululu ~]# cd /opt</code></span>\n        </div> \n        <div class=\"line number2 index1 alt1\">\n         <span style=\"font-size: 14px\"><code class=\"csharp plain\">[root@mululu opt]# mkdir nmon</code></span>\n        </div> \n        <div class=\"line number3 index2 alt2\">\n         <span style=\"font-size: 14px\"><code class=\"csharp plain\">[root@mululu opt]# cd nmon</code></span>\n        </div> \n        <div class=\"line number4 index3 alt1\">\n         <span style=\"font-size: 14px\"><code class=\"csharp plain\">[root@mululu nmon]#wget&nbsp;&lt;a href=</code><code class=\"csharp string\">\"http://sourceforge.net/projects/nmon/files/download/nmon_x86_12a.zip/download\"</code><code class=\"csharp plain\">&gt;http://sourceforge.net/projects/nmon/files/download/nmon_x86_12a.zip&lt;/a&gt;</code></span>\n        </div> \n       </div> </td> \n     </tr> \n    </tbody> \n   </table> \n  </div> \n </div> \n</div> \n<p><strong>方法2：</strong></p> \n<p>点击第一个链接，下载列表中的<a class=\"g_file_name_link\" href=\"http://osdn.jp/projects/sfnet_nmon/downloads/nmon_linux_14i_newer_Linux_versions.tar.gz/\">nmon_linux_14i_newer_Linux_versions.tar.gz</a>，解压后里边有很多版本的nmon，我用的是nmon_linux_x86_64，亲测可用。根据linux系统版本，使用其他版本可能会提示glibc版本太低，需要安装更高版本的glibc，遇到这种问题请参考<a target=\"_blank\">http://blog.csdn.net/cpplang/article/details/8462768</a>。</p> \n<p>直接在window中将解压好的nmon_linux_x86_64通过sftp上传到要监控的linux系统中对应目录下</p> \n<p>&nbsp;</p> \n<p><span style=\"font-size: 16px\"><strong>二、初始化工具</strong></span></p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"font-size: 14px\"><span style=\"color: #ff0000\">[</span><span style=\"color: #ff0000\">root@lampard nmon</span><span style=\"color: #ff0000\">]</span><span style=\"color: #000000\"># <strong>unzip nmon_x86_12a.zip</strong> Archive: nmon_x86_12a.zip inflating: nmon_x86_rhel45 inflating: nmon_x86_rhel52 inflating: nmon_x86_sles9 inflating: nmon_x86_sles10 inflating: nmon_x86_ubuntu810 inflating: nmon_x86_fedora10 inflating: nmon_x86_opensuse10 </span><span style=\"color: #ff0000\">[</span><span style=\"color: #ff0000\">root@lampard nmon</span><span style=\"color: #ff0000\">]</span><span style=\"color: #000000\"># ls nmon1 nmon_x86_fedora10 nmon_x86_rhel45 nmon_x86_sles10 nmon_x86_ubuntu810 nmon_x86_12a.zip nmon_x86_opensuse10 nmon_x86_rhel52 nmon_x86_sles9 </span><span style=\"color: #ff0000\">[</span><span style=\"color: #ff0000\">root@lampard nmon</span><span style=\"color: #ff0000\">]</span><span style=\"color: #000000\"># <strong>mv nmon_x86_ubuntu810 nmon</strong> <span style=\"color: #ff6600\">#重命名nmon </span></span><span style=\"color: #ff0000\">[</span><span style=\"color: #ff0000\">root@lampard nmon</span><span style=\"color: #ff0000\">]</span># <strong>chmod <span style=\"color: #808080\">+</span></strong><span style=\"color: #000000\"><strong>x nmon</strong> </span></span><span style=\"color: #ff6600; font-size: 14px\">#授权命令</span></pre> \n <pre><span style=\"font-size: 14px\"><span style=\"color: #ff0000\">[</span><span style=\"color: #ff0000\">root@lampard nmon</span><span style=\"color: #ff0000\">]</span><span style=\"color: #000000\">#ls <br>nmon nmon1 nmon_x86_12a.zip nmon_x86_fedora10 nmon_x86_opensuse10 nmon_x86_rhel45 nmon_x86_rhel52 nmon_x86_sles10 nmon_x86_sles9</span></span></pre> \n</div> \n<p>然后直接运行 nmon 即可，直接运行nmon可以实时监控系统资源的使用情况，执行下面的步骤可以展现一段时间系统资源消耗的报告。</p> \n<p>下面是直接执行nmon命令实时监控系统资源消耗情况的截图：</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"font-size: 14px\">[root@lampard nmon]#./nmon</span></pre> \n</div> \n<p><img src=\"null2019/01/03/09d82c8f-c642-4aeb-bf15-abe1364a184a.png\" alt=\"\"></p> \n<p><img src=\"null2019/01/03/f121723d-81c1-4ebc-8830-92e905bff5c0.png\" alt=\"\"></p> \n<p>CPU、内存、磁盘和网络的消耗情况都被很直观的展现出来。</p> \n<p>按键“<strong>C</strong>”可以查看CPU相 关信息；</p> \n<p>按键“<strong>D</strong>”可以查看磁盘信息；</p> \n<p>按键“<strong>T</strong>”可以查看系统的进程信息；</p> \n<p>“<strong>M</strong>”对应内存、“<strong>N</strong>”对应网络等等；</p> \n<p>完整的快捷键对应内容可以通过帮助（按键 “<strong>H</strong>”）查看。</p> \n<p>可以显示Linux系统CPU、内存、进程信息，包括了CPU的用户、系统、等待和空闲状态值，可用内存、缓存大小以及进程的CPU消耗等详细指标。该种方式显示信息实时性强，能够及时掌握系统承受压力下的运行情况，每颗CPU利用率是多少、内存使用多少、网络流量多少、磁盘读写……这些数据均是实时刷新，一目了然。</p> \n<p>&nbsp;</p> \n<p><span style=\"font-size: 16px\"><strong>三、生成nmon报告</strong></span><br><br><strong>1).采集数据：</strong><br>#&nbsp; ./nmon -s10 -c60 -f -m /home/</p> \n<p><span style=\"font-size: 14px\">参数解释：</span><br><span style=\"font-size: 16px\">-s10&nbsp; &nbsp; &nbsp; 每 10 秒采集一次数据。</span><br><span style=\"font-size: 16px\">-c60&nbsp; &nbsp; &nbsp; 采集 60 次，即为采集十分钟的数据。</span><br><span style=\"font-size: 16px\">-f&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;生成的数据文件名中包含文件创建的时间。</span><br><span style=\"font-size: 16px\">-m&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;生成的数据文件的存放目录。</span></p> \n<p><span style=\"font-size: 16px\">这样就会生成一个 nmon 文件，并每十秒更新一次，直到十分钟后。</span><br><span style=\"font-size: 16px\">生成的文件名如： lampard_190103_1506.nmon ，\"lampard\" 是这台主机的主机名。</span></p> \n<p><span style=\"font-size: 16px\"><strong>nmon -h&nbsp; &nbsp; &nbsp; &nbsp;</strong>查看更多帮助信息</span></p> \n<p>---------------------------------------</p> \n<p>---------------------------------------</p> \n<p><strong>！！！</strong>可能会遇到下面问题</p> \n<p><img src=\"null2019/01/03/4c3f1308-35be-48b8-82d1-8a27ce2c2d04.png\" alt=\"\" width=\"485\" height=\"77\"></p> \n<p>解决方式：</p> \n<div class=\"cnblogs_code\"> \n <div class=\"cnblogs_code_toolbar\">\n  <span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"null2019/01/03/4d8d0c17-7ace-422b-9ecc-961ab26162b9.gif\" alt=\"复制代码\"></a></span>\n </div> \n <pre><span style=\"font-size: 14px\">先看看这个命令属于哪个软件包：\n[root@lampard ~]#  <strong>yum provides */lsb_release</strong>\nLoaded plugins: fastestmirror\nLoading mirror speeds from cached hostfile\n* base: mirrors.psychz.net\n* epel: mirrors.solfo.com\n* extras: mirror.san.fastserv.com\n* updates: mirror.lax.hugeserver.com\nbase/filelists_db                                                       | 5.1 MB     00:00\nepel/filelists_db                                                       | 7.8 MB     00:00\nextras/filelists_db                                                     |  31 kB     00:00\nupdates/filelists_db                                                    | 614 kB     00:00\nvz-base/filelists                                                       |  825 B     00:00\nvz-updates/filelists                                                    | 3.0 kB     00:00\nredhat-lsb-core-4.0-7.el6.centos.i686 : LSB base libraries support for CentOS\nRepo        : base\nMatched from:\nFilename    : /usr/bin/lsb_release\ndkms-2.2.0.3-28.git.7c3e7c5.el6.noarch : Dynamic Kernel Module Support Framework\nRepo        : epel\nMatched from:\nFilename    : /usr/lib/dkms/lsb_release\ndkms-2.2.0.3-26.el6.noarch : Dynamic Kernel Module Support Framework\nRepo        : installed\nMatched from:\nFilename    : /usr/lib/dkms/lsb_release\nredhat-lsb-core-4.0-7.el6.centos.i686 : LSB base libraries support for CentOS\nRepo        : installed\nMatched from:\nFilename    : /usr/bin/lsb_release\n\n可以看出，属于redhat-lsb这个包，那么接着使用yum安装这个包：\n[root@lampard ~]# <strong>yum install -y redhat-lsb</strong>\n[root@lampard ~]# <strong>lsb_release -r</strong></span></pre> \n <div class=\"cnblogs_code_toolbar\">\n  <span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"null2019/01/03/4d8d0c17-7ace-422b-9ecc-961ab26162b9.gif\" alt=\"复制代码\"></a></span>\n </div> \n</div> \n<p>&nbsp;</p> \n<p><span style=\"font-size: 14px\">2).<strong>生成报表：</strong></span></p> \n<p>下载 nmon analyser (生成性能报告的免费工具)：<br><a href=\"https://www.ibm.com/developerworks/community/wikis/home?lang=en#!/wiki/Power%20Systems/page/nmon_analyser\" target=\"_blank\">https://www.ibm.com/developerworks/community/wikis/home?lang=en#!/wiki/Power%20Systems/page/nmon_analyser</a></p> \n<p><br>&nbsp; &nbsp;将之前生成的 nmon 数据文件传到 Windows 机器上，用 Excel 打开分析工具 nmon analyser v33C.xls 。点击 Excel 文件中的 \"<strong>Analyze nmon data</strong>\" 按钮，选择 nmon 数据文件，这样就会生成一个分析后的结果文件： hostname_090824_1306.nmon.xls ，用 Excel 打开生成的文件就可以<span style=\"font-size: 14px\">看到</span>结果了。</p> \n<p>!!&nbsp; 如果宏不能运行，需要做以下操作：<br><strong>工具 -&gt; 宏 -&gt; 安全性 -&gt; 中</strong>，然后再打开文件并允许运行宏。</p> \n<p><br>下面是在测试环境中生成的nmon报告截图：</p> \n<p><img src=\"null2019/01/03/aafac0b1-3543-4154-89da-48ceeabdb8d3.png\" alt=\"\"></p> \n<p>红色区域为不同指标的分析报告。</p> \n<p>&nbsp;</p> \n<p><span style=\"font-size: 14px\"><strong>3).<span style=\"font-size: 12px\">定时任务</span></strong></span></p> \n<p>&nbsp;&nbsp;&nbsp; 除配合性能测试的短期监控，也可以实现对系统的定期监控，作为运营维护阶段的参考。定期监控实现如下：</p> \n<p>1)&nbsp;&nbsp; 执行命令：# crontab&nbsp; –e&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<strong>#定时任务命令</strong></p> \n<p>2)&nbsp;&nbsp; 在最后一行添加如下命令：<br>0 8 * * 1,2,3,4,5&nbsp; /nmon/nmon_x86_rhel5&nbsp; -f -N -m /nmon/log&nbsp; -s 30 -c 1200<br><strong>表示：</strong><br>周一到周五，从早上08点开始，监控10个小时（到18:00整为止），输出到/nmon/log</p> \n<p><strong>自动按天采集数据：</strong><br>在 crontab 中增加一条记录：<br>0 0 * * * root nmon -s300 -c288 -f -m /home/ &gt; /dev/null 2&gt;&amp;1</p> \n<p>300*288=86400 秒，正好是一天的数据。</p> \n<p>&nbsp;</p> \n<p><span style=\"font-size: 16px\"><strong>四、停止监控</strong></span></p> \n<p>nmon运行本身是会消耗<span style=\"font-family: &quot;Microsoft YaHei&quot;\">系统</span>资源，如需关闭nmon，直接kill掉</p> \n<p># ps -ef | grep nmon&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (得到pid)</p> \n<p># kill -9 pid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(安全kill)</p> \n<p>&nbsp;</p> \n<p>-----------------------------------------------------------------</p> \n<p>-----------------------------------------------------------------</p> \n<p><span style=\"font-family: &quot;Microsoft YaHei&quot;\"><strong>！！！</strong>实际应用时遇到“nmon analyser&nbsp;运行时错误 13 类型不匹配”</span></p> \n<p><span style=\"font-family: &quot;Microsoft YaHei&quot;\">解决办法：&nbsp;将本机系统时间格式设置为：yyyy-MM-dd。电脑的计算机名不能有特殊字符。</span></p> \n<p>-----------------------------------------------------------------</p> \n<p>-----------------------------------------------------------------</p> \n<p>本文引用了其他文章。</p> \n<p>&nbsp;</p>', '2019-01-03 17:07:29', 'https://www.cnblogs.com/ailiailan/p/9479777.html');
INSERT INTO `t_blog` VALUES ('11', '浅谈Tomcat服务器优化方法', '<p>对于JavaWeb开发人员而言，Tomcat已成为默认的web服务器，但是在生产环境下使用Tomcat部署应用，我们如果采用Tomcat默认的配置，尤其是内存和线程的配置，其配置都很低，容易成为性能瓶颈，所以我们需要对Tomcat服务器进行优化，提升其运行性能，下面我们一起来看看Tomcat如何优化？</p> \n<p>&nbsp;</p> \n<p><strong>一、Tomcat内存优化，启动时告诉JVM需要多大内存</strong>（调优内存是最直接的方式）</p> \n<p>Windows 下的 catalina.bat</p> \n<p>Linux 下的 catalina.sh</p> \n<p>在该文件中配置jvm的内存空间，如: JAVA_OPTS=\'-Xms256m -Xmx512m\'</p> \n<p>-Xms&lt;size&gt; JVM初始化堆的大小</p> \n<p>-Xmx&lt;size&gt; JVM堆的最大值，实际参数大小根据服务器配置或者项目具体设置；</p> \n<p>&nbsp;</p> \n<p><strong>二、Tomcat 线程优化 在server.xml中配置</strong></p> \n<p>比如:</p> \n<p>&lt;Connector port=\"80\" protocol=\"HTTP/1.1\" maxThreads=\"600\" minSpareThreads=\"100\" maxSpareThreads=\"500\" acceptCount=\"700\"<br>connectionTimeout=\"20000\" &nbsp;/&gt;</p> \n<p><br>maxThreads=\"X\" 表示最多同时处理X个连接</p> \n<p>minSpareThreads=\"X\" 初始化X个连接</p> \n<p>maxSpareThreads=\"X\" 表示如果最多可以有X个线程，一旦超过X个,则会关闭不在需要的线程</p> \n<p>acceptCount=\"X\" 当同时连接的人数达到maxThreads时,还可以排队,队列大小为X.超过X就不处理</p> \n<p>&nbsp;</p> \n<p><strong>三、Tomcat IO 优化</strong></p> \n<p>1：同步阻塞IO（JAVA BIO） 同步并阻塞，服务器实现模式为一个连接一个线程（one connection one thread 想想都觉得恐怖，线程可是非常宝贵的资源），当然可以通过线程池机制改善.</p> \n<p>2：JAVA NIO 又分为同步非阻塞IO，异步阻塞IO与BIO最大的区别one request one thread.可以复用同一个线程处理多个connection(多路复用).</p> \n<p>3：异步非阻塞IO(Java NIO2又叫AIO) 主要与NIO的区别主要是操作系统的底层区别，可以做个比喻：比作快递，NIO就是网购后要自己到官网查下快递是否已经到了(可能是多次)，然后自己去取快递；AIO就是快递员送货上门了(不用关注快递进度)。</p> \n<p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解.</p> \n<p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持.</p> \n<p>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持.</p> \n<p>在server.xml中</p> \n<p>&lt;Connector port=\"80\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\"&nbsp;<br>&nbsp; &nbsp; connectionTimeout=\"20000\"&nbsp;<br>&nbsp; &nbsp; URIEncoding=\"UTF-8\"&nbsp;<br>&nbsp; &nbsp; useBodyEncodingForURI=\"true\"&nbsp;<br>&nbsp; &nbsp; enableLookups=\"false\"&nbsp;<br>&nbsp; &nbsp; redirectPort=\"8443\" /&gt;</p> \n<p>实现对Tomcat的IO切换。</p> \n<p>&nbsp;</p> \n<p><strong>四、大杀器APR</strong></p> \n<p>APR是从操作系统级别来解决异步的IO问题，大幅度的提高性能. (http://apr.apache.org/)。</p> \n<p>APR(Apache Portable Runtime)是一个高可移植库，它是Apache HTTP Server 2.x 的核心，能更好地和其它本地web技术集成，总体上让Java更有效率作为一个高性能web服务器平台而不是简单作为后台容器；</p> \n<p>在产品环境中，特别是直接使用Tomcat做WEB服务器的时候，应该使用Tomcat Native来提高其性能，如果不配APR，基本上300个线程狠快就会用满，以后的请求就只好等待.但是配上APR之后，并发的线程数量明显下降，从原来的300可能会马上下降到只有几十，新的请求会毫无阻塞的进来；</p> \n<p>在局域网环境测，就算是400个并发，也是一瞬间就处理/传输完毕，但是在真实的Internet环境下，页面处理时间只占0.1%都不到，绝大部分时间都用来页面传输，如果不用APR，一个线程同一时间只能处理一个用户，势必会造成阻塞，所以生产环境下用apr是非常必要的.</p> \n<p>安装Apache Tomcat Native Library，直接启动就支持apr(http://tomcat.apache.org/native-doc/)它本身是基于APR的，排除代码问题Tomcat优化到这个层次,可以应对大部分性能需求；</p> \n<p>最后，优化的前提条件是良好的代码质量和设计。</p>', '2019-01-03 17:07:29', 'https://www.cnblogs.com/bjpowernodejava/p/10214351.html');
INSERT INTO `t_blog` VALUES ('12', '程序员工作之外，如何再赚一份工资？', '<p>很多程序员兄弟们工资不高，但时间还是比较充足的，剩下的时间想多搞点外快，毕竟要养家糊口。</p> \n<p>我来讲讲怎么做可以一个月轻松多赚2万多元的外快。（<strong>纯干货分享！</strong>）</p> \n<p>&nbsp;</p> \n<p><strong>一、接项目</strong></p> \n<p>是程序员都想过接私活，但真正去做了的寥寥无几。</p> \n<p><strong>可能的原因：</strong></p> \n<p>1、工作忙天天加班没时间</p> \n<p>2、有时间但不知道从哪找项目，针对第一点我就不多说了，你还是先干好本职工作再说私活的事儿；如果不知道去哪里找项目，这可就是你的不对了，一看就是平时在这方面不用心（想发财难哦~）今天我给大家推荐几个不错接单平台，猪八戒网都知道我就不说了，像解放号、云沃客、码市、程序员客栈等平台，每天都在公布招标项目，一般都是10万以上的项目，也有适合个人的一两万的小项目 ，大项目可以多人投标，中标后几个人组团开发，一起撸码，一起挣钱。总的来说，平均一个月下来，几千块钱是能搞到的，就是有点累，哈哈。</p> \n<p>&nbsp;</p> \n<p><strong>二、做个兼职讲师</strong></p> \n<p>如果你技术过硬（怎么评判自己的技术水平？简单说至少得是公司的技术骨干）而且又在一个背景不错的公司，不用非得BAT企业，在行业有一些名气就可以，你又善于语言表达，最好还有一些个人魅力，比如语言幽默，声音磁感强等，这算占得天时地利人和了，具备这些条件一定要好好利用！</p> \n<p>&nbsp;</p> \n<p>你可以选择去技术培训机构，或者一些在线教育机构，定期讲课或录课程，收入一般都是按照小时算的，一小时一两千很常见。因为你来自开发一线，对技术敏感，如果课程叫卖，你可能一下子就火了，到时候你可以提出来个抽成，卖出多少课分你几个点（想想就很美~~）当然这是后话。</p> \n<p>&nbsp;</p> \n<p>在前期假如你一个月录10个小时的课，一小时一千，这个月你就有1万的额外收入，怎么样是不是非常不错！</p> \n<p>在哪找这样的兼职的？网上搜一些培训机构直接问，或者去招聘网站搜，肯定有的！</p> \n<p>&nbsp;</p> \n<p><strong>如果上面2种你都觉得不喜欢，我来跟你说说第三种，你应该感兴趣</strong></p> \n<p>&nbsp;</p> \n<p><strong>三、做运营</strong></p> \n<p>借助微信公众号/微博/今日头条/知乎这样的流量比较大的平台，开自己的专栏，先建立自己的种子粉丝，这时候你的文章就会像“病毒”一样广泛传播，广告商自然就来了。</p> \n<p>下面是详细教程，可以下载看看&nbsp;&nbsp;<a href=\"https://pan.baidu.com/s/134Z9Tvi92AoiIR2hRfCThQ\" target=\"_blank\">https://pan.baidu.com/s/134Z9Tvi92AoiIR2hRfCThQ</a></p> \n<p>&nbsp;</p>', '2019-01-03 17:07:29', 'https://www.cnblogs.com/java-chen-hao/p/10214085.html');
INSERT INTO `t_blog` VALUES ('13', '知识图谱基础知识之二——知识图谱的构建方法', '<p>上次介绍了知识图谱的一些基本概念，这次我们来谈谈知识图谱的构建方法。 我们知道知识图谱的数据是通过三元组（主语，谓词，宾语）的方式进行组织，每一个三元组代表一条知识，这些三元组并不是杂乱无章的堆砌在知识图谱中，而是按照一定的逻辑组织起来的。</p> \n<h1>1 知识图谱的数据结构</h1> \n<p>从知识图谱数据组织的架构来看，可以把知识图谱的数据分为两个层次，一个是数据模型层，数据模型是按照本体论的思想，勾画出来的数据组织模式，数据模型可以展示数据的组织方式，数据之间的相互关系，创建动植物的数据模型，可以按照动植物的通用分类标准，使用七个主要级别：界、门、纲、目、科、属、种 。可以将动植物的数据按照这个模型进行组织。&nbsp;<img src=\"http://127.0.0.1:51004/local/RTpcc3R1ZHlc5paH54mp55-l6K-G5Zu-6LCx5p6E5bu6XGtnXOaehOW7uuaWueazlVxjbGFzc2lmeS5wbmc=\" alt=\"a instance of classify\">&nbsp;数据模型可以看作是元数据，依据数据模型，数据才能得到有效的组织。数据模型除了确定对象之间的分类，关系，还要明确对象的属性，针对不同的知识图谱，需要收集的数据的内容也不相同，内容范围由对象的属性确定。数据模型的分类，关系反映了数据之间的关系特征，数据模型的属性反映了数据的内在特征。 另一个就是具体数据层，具体数据是一条条的知识，它是依据数据模型组织起来的。我们可以把数据模型看作是骨架，把具体数据看作是肌肉，两部分共同组成了一个健壮的整体，就是我们的知识图谱。不同类型的知识图谱，组织数据的方式也有所不同，涉及到具体数据，具体数据的内容也有差别。比如对于一个人物来说，如果是历史知识图谱，可能人物数据的内容主要侧重于人物的生平，主要事迹，人物关系等等，如果是文学知识图谱，人物数据的内容则会主要侧重人物的主要作品，师承关系，作品流派等等。 将知识图谱的数据分成了两个层次，在构建知识图谱的时候，是先确定数据模型再收集具体数据，还是先收集具体数据再确定数据模型，这就形成了两种构建知识图谱的方式。</p> \n<h1>2 自顶向下的构建方式</h1> \n<p>自顶向下的构建方式，是指先确定知识图谱的数据模型，再根据模型去填充具体数据，最终形成知识图谱。数据模型的设计，是知识图谱的顶层设计，根据知识图谱的特点确定数据模型，就相当于确定了知识图谱收集数据的范围，以及数据的组织方式。这种构建方式，一般适用于行业知识图谱的构建，对于一个行业来说，数据内容，数据组织方式相对来说比较容易确定。比如对于法律领域的知识图谱，可能会以法律分类，法律条文，法律案例等等的方式组织。再比如建立一个三国时期人物的知识图谱，可能会以某个历史时期，魏蜀吴三个国家将人物进行分类，统计人物的师承，上下属，朋友，敌对等等关系，依据这些关系设计数据模型，然后再收集具体人物数据，形成人物的知识图谱。总起来说，自顶向下的构建方式，适用于那些知识内容比较明确，关系比较清晰的领域构建知识图谱。</p> \n<h1>3 自下向上的构建方式</h1> \n<p>自下向上的构建方式，是指先按照三元组的方式收集具体数据，然后根据数据内容来提炼数据模型。 采用这种方式构建知识图谱，是因为在开始构建知识图谱的时候，还不清楚收集数据的范围，也不清楚数据怎么使用，就是先把所有的数据收集起来，形成一个庞大的数据集，然后再根据数据内容，总结数据的特点，将数据进行整理、分析、归纳、总结，形成一个框架，也就是数据模型。一般公共领域的知识图谱采用这种方式，因为公共领域的知识图谱，涉及到海量数据，并且包括方方面面的知识，做出来的效果是大而全，这在构建初期，很难想清楚数据的整体架构，只能是根据数据的内容总结提炼特征，形成数据框架模型。比如google，百度的知识图谱，属于典型的公共领域知识图谱，现实中，使用他们的搜索工具进行内容搜索时，用户可能输入的内容千差万别，各个领域的问题都可能问到，也就使得他们的后台知识图谱内容也要覆盖所有知识，在构建他们这种公共领域的知识图谱过程中，随着数据的不断积累，才会对数据知识进行分类，慢慢呈现出知识架构。</p> \n<h1>4 结语</h1> \n<p>当然，两种构建方式也不是一成不变的，在构建初期两种方式区别很明显，在知识图谱构建后期，两种方式可能会结合使用。对于自顶向下的构建方式，随着数据量的不断积累，可能会发现原来的数据模型并不完善，有很多数据可能没有包含在数据模型的体系中，这时候就需要修订数据模型，根据数据的特点，完善数据模型。同样，在自下向上的构建方式中，慢慢形成的数据模型，对于后期的数据收集，也有一定的指导作用，按照形成的数据模型，可以快速准确地收集相关数据。总之，数据和数据模型之间，是一个相辅相成的关系，二者在构建知识图谱的过程中缺一不可。</p>', '2019-01-03 17:07:36', 'https://www.cnblogs.com/coodream2009/p/10213819.html');
INSERT INTO `t_blog` VALUES ('14', '从零开始学习PYTHON3讲义（十五）让画面动起来', '<p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1545112916052&amp;di=d2428f9e946cda2d7df3f0ca9ff3def8&amp;imgtype=0&amp;src=http%3A%2F%2Finsights.thoughtworkers.org%2Fwp-content%2Fuploads%2F2015%2F07%2F718-%25E4%25BD%259F%25E8%25BE%25BE-%25E5%2585%25A8%25E6%25A0%2588%25E5%25BC%2580%25E5%258F%2591%25E8%25AF%25AD%25E8%25A8%2580Python-1024x724.png\"></p> \n<h3 id=\"从零开始python3第十五讲\">《从零开始PYTHON3》第十五讲</h3> \n<p>虽然看起来绘图和音乐并不相关，但是听过了上一讲的内容你一定知道，这是游戏编程中四个需要处理内容的两部分，这两部分必须同时、并行的处理，不能因为某一项计算的拖延，导致另外一方程序的停滞。要知道人对声音的断续和游戏的卡顿是很敏感的。</p> \n<p>在Pygame中进行并行处理的主要手段，一是Pygame中的各种函数，大多是不等待工作完成，只要工作开始进行，就返回主程序，等待下一条命令，而任务会在看不到的后端继续执行，并不停止；另外则是各个并行的任务之间，会通过“消息事件”的方式跟主程序沟通，从而让主程序能够统一调度各项任务的进程。</p> \n<p>这是复习上一讲的内容。</p> \n<blockquote> \n <p>并行：指的是在硬件的帮助下，多个任务同时进行，互不影响，最终完成任务的过程。完成的时间取决于最慢的任务。这个硬件帮助，通常是指多核CPU、显卡计算配合CPU计算以及数据传输中的多通道。<br> 串行：指的是完成一项工作，才进行另外一项工作，最后完成的时间是所有任务完成的总和。</p> \n</blockquote> \n<hr> \n<h4 id=\"游戏绘图\">游戏绘图</h4> \n<h5 id=\"绘图模式\">绘图模式</h5> \n<p>同我们前面学过的科学绘图和海龟绘图相比，游戏绘图在绘图的模式上有较大的区别。</p> \n<p>传统程序绘图是顺序方式，每画一笔可以认为这一笔一直都在，直到程序退出或者擦除画面。你可以回忆一下我们在科学绘图和海龟绘图时候所学习的内容。<br> 游戏绘图更类似拍照，一个个角色进入画面，摆好姿态，等待快门按下，这样完成一帧。随后会根据游戏逻辑和输入，调整画面，再拍摄下一张，这样至少达到每秒30帧，才能达成一个动画的效果。</p> \n<p>从逻辑上讲，游戏绘图采用的方式似乎应当慢于传统方式。实际上因为这种方式能够得到CPU/显卡以及很多新技术的帮助。很多绘图任务发出后，实际上是进入显卡完成运算的，这时候CPU已经在处理其它内容。这样并行计算的方式，再加上显卡更善于处理图形、图像相关的工作。最终这种方式效率才会高很多。</p> \n<p>我们前面讲的科学绘图和海龟绘图，新版本的实现有很多是使用游戏绘图的方式，通过并行的方式完成计算。但因为用户编程接口的兼容性，所以至少从我们编程时所感受到的方式上，还是串行处理的。</p> \n<h5 id=\"坐标系\">坐标系</h5> \n<p>科技绘图（matplotlib）：采用数学坐标系，同显示设备无关,通常原点在屏幕中心。绘图包会自动调整数学坐标系跟窗口分辨率的比例（窗口分辨率是可以在程序中设置的，只是前面的学习中我们基本使用了默认的设置），从而让显示效果最优。<br> 海龟绘图（turtle）：原点在窗口中心，跟数学坐标系方向相同，坐标是同显示设备分辨率相关的，但绘图的操作通常是用几何的方式，所以不用太担心显示设备本身的分辨率。<br> 游戏绘图(pygame):原点在窗口左上角，x轴坐标向右侧增大，y轴坐标向下增大，最大值为屏幕分辨率。还有一些更底层的游戏绘图引擎，比如OpenGL会使用统一的1.0*1.0坐标系，然后在不同设备上映射成不同的分辨率。我们本讲的课程采用Pygame所使用的坐标体系。</p> \n<h5 id=\"颜色\">颜色</h5> \n<p>在计算机中常用的颜色分类有这么几种：</p> \n<ul> \n <li>二值图：仅有黑白两色，比如字体库</li> \n <li>灰度图：0-255，共256级灰度，比如黑白照片</li> \n <li>伪彩色：0-255,共256种颜色，比如GIF动图、微信表情</li> \n <li>真彩色：RGB红绿蓝三色图，每种颜色0-255，按二进制计算，也称为24位色</li> \n <li>32位真彩色：RGBA四色，除了红绿蓝之外，A代表透明度，能表现更多的多种颜色互动、遮盖的效果</li> \n</ul> \n<p>这些颜色格式Pygame都支持，但最新的游戏通常都已经采用32位真彩色的方式。<br> 在游戏的显示过程中，如果不考虑透明度A的部分，所有颜色都是使用“三基色”来表达的，也就是红、绿、蓝，每个颜色分量可以的取值分为是0到255。0表示完全没有这个颜色，255表示这个颜色最强。当三个颜色都是0的时候显示为纯黑。当三个颜色都是255的时候，显示为纯白。<br> 因为是三个颜色，所以通常的颜色都是使用三个值的“元组”的形式表达的。元组我们第九讲学过了。下面举一些例子，我们在程序中，预定义几个常用的颜色：</p> \n<pre class=\"python\"><code>#黑色\nBLACK =(0, 0, 0)\n#白色\nWHITE = (255, 255, 255)\n#红色\nRED = (255,0,0)\n#绿色\nGREEN =(0,255,0)\n#蓝色\nBLUE=(0, 0,255)</code></pre> \n<hr> \n<h5 id=\"pygame程序一般结构\">Pygame程序一般结构</h5> \n<p>上一讲和本讲开始我们都已经讲过，Pygame的主要工作模式是并行处理，其结构同传统的串行程序就必然有一些差别。这个差别并不大，很类似我们学习互联网编程时候的框架模板，即使不够理解，照抄下来用就可以。下面就是一个一般的结构：</p> \n<pre class=\"python\"><code>#此代码仅为架构示例,没有具体功能\n#作者：Andrew\n\n#引入扩展库\nimport pygame\n\nwidth=1280\nheigh=556\ncolor=32\n\n#pygame初始化\npygame.display.init()\n#创建一个绘图平面,后面参数为设定的窗口分辨率及颜色\nscreen = pygame.display.set_mode((width, heigh), 0, color)\n#声音系统初始化\npygame.mixer.init()\n\n#1...其它自身初始化项目...\n\n#是否要退出标志\nrequireQuit = False\n#程序主循环，在有退出申请之前一直循环\nwhile not requireQuit:\n    #2...自己的绘图部分...\n\n    #处理所有事件\n    for event in pygame.event.get():\n        #用户从窗口菜单选择退出\n        if event.type == pygame.QUIT:\n            requireQuit=True\n            break\n        #用户是否有按键？\n        elif event.type == pygame.KEYUP:\n            #为了可靠，只处理按键松开的动作\n            if event.key in [pygame.K_q,pygame.K_ESCAPE]:\n                #用户按了q键\n                requireQuit=True\n                break\n        #3...其它事件处理...\n    #4...其它程序逻辑...\n\n#优雅的退出，释放各种资源\npygame.mixer.quit()\npygame.display.quit()</code></pre> \n<p>上面的代码中，并不包含任何功能，只是一个模板。通常没有特殊需求的程序，只要编写其中的#1/#2/#3/#4部分的程序就可以。<br> 为了程序更便于理解和阅读，还可以对上面的结构进一步的优化，比如把需要继续编程的部分函数化。当然函数化的时候要考虑到变量作用域，避免增加不必要的麻烦。</p> \n<hr> \n<h5 id=\"常用绘图功能\">常用绘图功能</h5> \n<p>我们介绍几个常用的绘图功能，然后就可以代入到上面的模板代码中来实验了。</p> \n<p>一般的几何图形绘制功能，都汇总在pygame.draw包中，比如：</p> \n<ul> \n <li>画圆：pygame.draw.circle</li> \n <li>矩形：pygame.draw.rect</li> \n <li>多边形：pygame.draw.polygon</li> \n <li>画线：pygame.draw.line</li> \n <li>画弧线：pygame.draw.arc</li> \n <li>画矩形：pygame.draw.rect</li> \n</ul> \n<p>正常情况下，pygame的显示是在一个窗口中显示的（也可以根据需要设置全屏），窗口可以设置一个标题来表示你当前做的工作，这个命令是：</p> \n<pre class=\"python\"><code>#设置窗口标题\npygame.display.set_caption(\'Hello World!\')</code></pre> \n<p>用于显示的窗口默认是没有颜色，也就是黑色，可以设置窗口的底色：</p> \n<pre class=\"python\"><code>#用白色填充窗口，既是设置窗口底色，也是把窗口清空，重新绘制下一帧\n#pygame绘图是像摄影师拍摄每一帧的照片，还记得吗？\nscreen.fill(WHITE)</code></pre> \n<p>还有一些函数的功能，可以参考help(pygame)。help也可以查看某一个具体的子包，比如:help(pygame.draw)。下面我们通过程序示例代码来看看刚才讲的这些功能：</p> \n<pre class=\"python\"><code>#我们定义一个函数，来完成画面的绘制\n#避免过多的语句挤入到主循环中影响程序的结构\ndef draw(screen):\n    #2...自己的绘图部分...\n    #用白色填充窗口\n    screen.fill(WHITE)\n    #画多边形\n    pygame.draw.polygon(screen, GREEN, ((146, 0), (291, 106), (236, 277), (56, 277), (0, 106)))\n    #画线\n    pygame.draw.line(screen, BLUE, (60, 60), (120, 60), 4)\n    pygame.draw.line(screen, BLUE, (120, 60), (60, 120))\n    pygame.draw.line(screen, BLUE, (60, 120), (120, 120), 4)\n    #画圆\n    pygame.draw.circle(screen, BLUE, (300, 50), 20, 0)\n        #椭圆\n    pygame.draw.ellipse(screen, RED, (300, 250, 40, 80), 1)\n    #矩形\n    pygame.draw.rect(screen, RED, (200, 150, 100, 50))\n\n    #使用直接操作图形缓存的方法在右下角画四个点\n    #这个功能比较底层，除非需要很专业的操作一般用不到\n    pixObj = pygame.PixelArray(screen)\n    pixObj[480][380] = BLACK\n    pixObj[482][382] = BLACK\n    pixObj[484][384] = BLACK\n    pixObj[486][386] = BLACK\n    pixObj[488][388] = BLACK\n    del pixObj\n\n    #显示在屏幕上\n    pygame.display.update()</code></pre> \n<p>上面代码只列出了自己定义的绘图部分，其它部分需要融合到框架模板中去。完整的代码可以参考code2.py源文件。<br> 下面的图片是绘制的效果：<br> <img src=\"null2019/01/03/e2fce373-12a7-4d74-b1a9-17131f3a9206.png\" alt=\"pygameDraw1\"><br> 程序运行之后，可以按q键退出程序，也可以从菜单选择Quit来退出。</p> \n<p>老话题，想掌握学习的知识，只能多练习。<br> 请在上面程序的基础，调整各项参数，增加或者减少绘图的指令，自己练练。看看谁绘制的画面最好看。</p> \n<hr> \n<h4 id=\"挑战\">挑战</h4> \n<p>我们已经掌握了基本的绘图知识。可惜游戏没有这么简单，至少游戏需要是以动画的方式为基础，玩起来才会感觉到真实。</p> \n<p>我们早已经说过，现代的游戏开发已经是一个团队配合的产物。不管想达成什么样的动画，一般都需要有美工专业人员完成原画的设计制作，提供成素材，随后才能由程序人员来完成让画面动起来的工作。</p> \n<p>我们这里已经从网上下载了几个素材：<br> <img src=\"null2019/01/03/ffb6f498-8860-436c-baf9-5323bd1079cf.png\" alt=\"pygameDraw2\"><br> 上面包含两个动画元素的素材，上面部分是一只小地鼠，仔细观察这四副图片，他们的脚在不同的位置。四张图片代表动画中的4帧，连续起来，就会出现小地鼠在跑的样子。<br> 下面的箭比较简单，只需要一帧，箭的图片出现在屏幕不同的位置上，感觉起来就是箭飞到了那个位置。<br> 如果你还记得第一讲的演示，你应当能看出来这些素材出自游戏Bunny。</p> \n<p>下面我们编程序，来实现小地鼠从屏幕右侧快速跑到屏幕左侧的动画，和羽箭从屏幕左侧飞到右侧的动画。</p> \n<pre class=\"python\"><code>#使用pygame对图片处理的功能，载入图片到变量\narrow = pygame.image.load(\"bullet.png\")\n#地鼠因为包含四帧，我们使用列表格式\nbadguy = [pygame.image.load(\"badguy.png\"),\n    pygame.image.load(\"badguy2.png\"),\n    pygame.image.load(\"badguy3.png\"),\n    pygame.image.load(\"badguy4.png\")]\n#动画动起来，需要一帧帧的变化，下面的变量用于指当前显示的第几帧\nbadguyIndex = 0\n\n\n#定义x1/y1和x2/y2两组坐标，\n#分别用于表示羽箭和小地鼠在屏幕上的位置\n\n#坐标系还记得吧？左上角是0，y向下变大，x向右变大\nx1=0   #羽箭从左侧飞到右侧，开始x坐标是0，表示在左侧\ny1=heigh/3#y坐标，在窗口上面的1/3位置\n\nx2=width    #小地鼠一开始在屏幕右侧\ny2=heigh/3*2\n\n#定义一个函数，用于计算向左移动时候下一个位置的坐标\ndef moveLeft(x):\n    x -= dx\n    if x &lt; 0:\n        x += width\n    return x\n#定义一个函数，用于计算向右移动时候下一个位置的坐标\ndef moveRight(x):\n    return (x+dx) % width\n\n#绘制的函数\ndef draw(screen):\n    screen.fill(WHITE)  #白色填充窗口\n    screen.blit(arrow,(x1,y1)) #绘制羽箭\n    screen.blit(badguy[badguyIndex],(x2,y2)) #绘制地鼠\n    #显示在屏幕上\n    pygame.display.update()\n    \n...\n\n    #4...其它程序逻辑...\n    #移动元素坐标位置的工作，应当放到“其它程序逻辑”中\n    #这样的方式使得程序逻辑，特别是绘图的逻辑干净易读\n    \n    x2 = moveLeft(x2)\n    x1 = moveRight(x1)\n    badguyIndex = (badguyIndex+1) % 4  #地鼠下次使用下一帧</code></pre> \n<p>上面代码依然去掉了同前面重复的部分，完整的代码请参考code3.py程序。现在运行一下看看吧：<br> <img src=\"null2019/01/03/2ae8bb26-3f67-4a00-97e0-85eb3b84e27a.png\" alt=\"pygameDraw3\"><br> 截图无法展示动态，你一定要亲自动手来试试，才能看到效果。关键点：</p> \n<ol> \n <li>屏幕绘制部分，根据坐标值，绘制指定的图片。</li> \n <li>在程序逻辑运算的部分，计算下一帧画面的时候，小地鼠和羽箭在屏幕上的新位置。以及地鼠的动画图片下次绘制采用哪一帧图片。</li> \n</ol> \n<hr> \n<h4 id=\"练习时间\">练习时间</h4> \n<ol> \n <li>修改上面程序的参数，让地鼠的速度加快一倍，而箭的速度保持不变</li> \n <li>上一讲中的mp3播放器，请实现在播放器播放的时候，显示一张歌曲的封面图片</li> \n</ol> \n<hr> \n<h4 id=\"本讲小结\">本讲小结</h4> \n<ul> \n <li>本讲介绍了使用pygame绘制基本几何图形和绘制简单动画的方式</li> \n <li>绘画、动画其实都不难，重要的是画面的设计，只要有了连续的图片，就可以用数组的方式来实现连续动画</li> \n <li>对于一个规模越来越大的程序，想少出错、容易维护，就需要代码尽量规范、简洁、函数化</li> \n</ul> \n<p>本课程至此就全部结束了。作为面对刚刚接触计算机软件编程的初学者课程，我们使用了15讲的篇幅，从Python的安装、命令行的互动计算开始，讲述了数学计算、程序逻辑控制、常用数据类型等基本Python编程的知识。接着又针对科技绘图、互联网编程、游戏编程等专业领域的应用做了讲解。时间所限，我们并没有能够特别深入对所有话题更进一步的学习。课程也没有对当前流行的面向对象编程做讲解，这些有待于学习者在对初级内容有了一段时间的熟悉和体验之后，继续深入学习。<br> 希望各位同学能在当前学习的基础上，根据自己的爱好和自己的日常学习、生活需要。有选择的做进一步学习，让Python成为我们学习的好助手，生活的得力工具。<br> 水平所限，课程内容难免疏漏、错误，敬请谅解并欢迎指正。</p> \n<hr> \n<h4 id=\"练习答案\">练习答案</h4> \n<p>请参考代码：mp3Player1.py</p> \n<ul> \n <li>连载正文结束，所有程序源码及练习答案将会整理后在下一期提供下载。</li> \n</ul>', '2019-01-03 17:07:50', 'https://www.cnblogs.com/andrewwang/p/10213811.html');
INSERT INTO `t_blog` VALUES ('15', 'MVC Scaffolding SmartCode-Engine 更新', '<h2>概述</h2> \n<p>通过扩展visual studio.net scaffolding组件,添加了一套功能完善的代码模板,包括Controller,Model,View,Businessd等各种功能的代码,配合Entity Framework Code-Frist功能实现快速构建业务系统的一套开发工具.</p> \n<h2>主要优势</h2> \n<p>市面上类似的代码生成工具有很多,但完全集成在visual studio.net以插件形式存在的几乎没有,大部分都是通过先定义表结构(数据字典)再运行工具生成对应的代码.然后再手工拷贝到对应的项目中,而改项目就是简单的多,只需要把实体对象定义出清楚,直接再项目中运行新增controller后选择需要的实体对象就可以.非常快捷.</p> \n<h3>不足之处</h3> \n<p>目前scaffolding组件只能在一个solution中的单个project中添加源代码文件,还没有办法降不同层的代码新建到对应的project中去,比如根据实体对应分别新建不同的project,对大型项目的分工会更好.</p> \n<h2>主要功能</h2> \n<ul> \n <li>与Visual Studio.Net 2017无缝集成</li> \n <li>快速生成标准的C.R.U.D代码</li> \n <li>符合经典的Asp.Net MVC5 N层架构</li> \n <li>运行环境.Net framework 4.7.1+</li> \n <li>支持Sql Server,MySql,Oracle等主流数据库</li> \n <li>前端Javascript采用ES6规范</li> \n</ul> \n<p><span style=\"font-size: 16px;\"><a class=\"github\" href=\"https://github.com/neozhu/MVC5-Scaffolder\" target=\"_blank\">Github</a>&nbsp;<a class=\"github\" href=\"https://marketplace.visualstudio.com/items?itemName=SmartCodeMVC5Enginever3898.SmartCodeMVC5Engine\" target=\"_blank\">download</a>&nbsp;<a class=\"github\" href=\"http://221.224.21.30:2022/\" target=\"_blank\">Demo</a></span></p> \n<h2><span style=\"font-size: 16px;\">细节提升</span></h2> \n<ul> \n <li>项目开始与2014年</li> \n <li>Controller升级异步执行采用(async/await)</li> \n <li>使用Microsoft Unity DI &amp; IoC</li> \n <li>前端采用Smart Admin模板</li> \n <li>前端控件一律采用Easyui组件</li> \n <li>前端Js Callback改成箭头函数(Arrow Function)加入(async/await)方法</li> \n <li>新增对数据编辑模式的设定一种是弹出窗口操作,一种是直接在datagrid内部开启编辑状态</li> \n <li>更友好更详细的操作信息的提示</li> \n</ul> \n<p>为什么使用EasyUI而不使用Smart Admin模板自带的标准Input.主要标准的Input虽然样式更漂亮,但功能比较单一,很多操作不是很方便,EasyUI社区比较活跃文档比较全面入手比较简单.但不足之处就是与responsive htmj兼容性不好,这里主要是我对easyui css不熟导致</p> \n<h2><span style=\"font-size: 16px;\">代码模板</span></h2> \n<table border=\"0\"> \n <tbody> \n  <tr> \n   <td>模板</td> \n   <td>功能</td> \n  </tr> \n  <tr> \n   <td>Controller.cs.t4</td> \n   <td>控制层代码与View层所有操作包括增删改查的全部功能</td> \n  </tr> \n  <tr> \n   <td>EntityQuery.cs.t4</td> \n   <td>查询逻辑的封装类参考<a href=\"https://github.com/urfnet/URF.NET\" target=\"_blank\">URF.NET</a>中的功能</td> \n  </tr> \n  <tr> \n   <td>EntityRepositoryExtension.cs.t4</td> \n   <td>对实体对象的增删改查的封装参考<a href=\"https://github.com/urfnet/URF.NET\" target=\"_blank\">URF.NET</a>中的功能</td> \n  </tr> \n  <tr> \n   <td>IEntityService.cs.t4</td> \n   <td>业务逻辑层代码参考<a href=\"https://github.com/urfnet/URF.NET\" target=\"_blank\">URF.NET</a>中的功能</td> \n  </tr> \n  <tr> \n   <td>EntityService.cs.t4</td> \n   <td>业务逻辑层具体实现的代码参考<a href=\"https://github.com/urfnet/URF.NET\" target=\"_blank\">URF.NET</a>中的功能</td> \n  </tr> \n  <tr> \n   <td>Index.cs.t4</td> \n   <td>主View代码包括datagrid现实,增删改查的功能实现</td> \n  </tr> \n  <tr> \n   <td>_PopupDetailFormView.cs.t4</td> \n   <td>弹出框操作表单</td> \n  </tr> \n  <tr> \n   <td>...</td> \n   <td>辅助功能代码</td> \n  </tr> \n  <tr> \n   <td>...</td> \n   <td>&nbsp;</td> \n  </tr> \n </tbody> \n</table> \n<p>&nbsp;</p> \n<h2><span style=\"font-size: 16px;\">Demo</span></h2> \n<p><span style=\"font-size: 16px;\"><img src=\"null2019/01/03/cc354c06-9f42-4b9d-aac6-c214ad5f9cd4.png\" alt=\"\"></span></p> \n<p><img src=\"null2019/01/03/4155d190-9b14-4cdf-9ea6-796fdb908e48.png\" alt=\"\"></p> \n<p><img src=\"null2019/01/03/9a12c34b-3592-4446-a7d1-2e94dfe5717e.png\" alt=\"\"></p> \n<p><img src=\"null2019/01/03/dc457582-1728-4306-be58-2281eb9a60e1.png\" alt=\"\"></p> \n<h3>项目案例</h3> \n<p><img src=\"null2019/01/03/593db118-41a7-402e-845a-5b69f2db435b.png\" alt=\"\"></p> \n<p>&nbsp;</p> \n<p>&nbsp;<img src=\"null2019/01/03/ed707193-f720-4249-965f-27a7bac3419c.png\" alt=\"\"></p> \n<h2>我的联系方式,欢迎讨论</h2> \n<p><img src=\"null2019/01/03/1b8fe66e-6d0b-4612-92ef-4d610e765ed4.png\" alt=\"\"></p> \n<p>&nbsp;</p>', '2019-01-03 17:07:58', 'https://www.cnblogs.com/neozhu/p/10213775.html');
INSERT INTO `t_blog` VALUES ('16', 'Spring 详解（二）------- AOP关键概念以及两种实现方式', '<p class=\"toc\">目录</p> \n<ul> \n <li><a href=\"#aop-%E5%85%B3%E9%94%AE%E8%AF%8D\">1. AOP 关键词</a></li> \n <li><a href=\"#aop-%E7%9A%84%E4%BD%9C%E7%94%A8\">2. AOP 的作用</a></li> \n <li><a href=\"#aop-%E7%9A%84%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B\">3. AOP 的通知类型</a></li> \n <li><a href=\"#%E5%9F%BA%E4%BA%8E-xml-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F\">4. 基于 xml 的配置方式</a></li> \n <li><a href=\"#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F\">5. 基于注解的配置方式</a></li> \n <li><a href=\"#%E5%88%87%E9%9D%A2%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7\">6. 切面的优先级</a></li> \n <li><a href=\"#%E9%87%8D%E7%94%A8%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F\">7. 重用切点表达式</a></li> \n <li><a href=\"#%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83%E6%91%98%E8%87%AA-spring-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3\">8. 两种方式的比较（摘自 spring 官方文档）</a></li> \n</ul> \n<hr> \n<p><br></p> \n<h3 id=\"aop-关键词\">1. AOP 关键词</h3> \n<p><br></p> \n<ul> \n <li>target：目标类，需要被代理的类。例如：ArithmeticCalculator</li> \n <li>Joinpoint(连接点)：所谓连接点是指那些可能被拦截到的方法。例如：所有的方法</li> \n <li>PointCut 切入点：已经被增强的连接点。例如：add()</li> \n <li>advice：通知/增强，增强代码。例如：showRaram、showResult</li> \n <li>Weaving(织入)：是指把增强 advice 应用到目标对象 target 来创建新的代理对象proxy的过程.</li> \n <li>proxy 代理类：通知+切入点</li> \n <li>Aspect(切面):：是切入点 pointcut 和通知 advice 的结合<br> <br></li> \n</ul> \n<h3 id=\"aop-的作用\">2. AOP 的作用</h3> \n<p><img src=\"null2019/01/03/b633b288-8f34-4603-a4cb-e884fcefa048.png\"><br> 当我们为系统做参数验证，登录权限验证或者日志操作等，为了实现代码复用，我们可能把日志处理抽离成一个新的方法。但是这样我们仍然必须手动插入这些方法，这样的话模块之间高耦合，不利于后期的维护和功能的扩展，有了 AOP 我们可以将功能抽成一个切面，代码复用好，低耦合。<br> <br></p> \n<h3 id=\"aop-的通知类型\">3. AOP 的通知类型</h3> \n<p><br><br> Spring 按照通知 Advice 在目标类方法的连接点位置，可以分为5类</p> \n<ul> \n <li>前置通知[Before advice]：在连接点前面执行，前置通知不会影响连接点的执行，除非此处抛出异常。</li> \n <li>正常返回通知[After returning advice]：在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行。</li> \n <li>异常返回通知[After throwing advice]：在连接点抛出异常后执行。</li> \n <li>返回通知[After (finally) advice]：在连接点执行完成后执行，不管是正常执行完成，还是抛出异常，都会执行返回通知中的内容。</li> \n <li>环绕通知[Around advice]：环绕通知围绕在连接点前后，比如一个方法调用的前后。这是最强大的通知类型，能在方法调用前后自定义一些操作。环绕通知还需要负责决定是继续处理join point(调用ProceedingJoinPoint的proceed方法)还是中断执行。<br> <br><br> Spring 中使用五种通知</li> \n</ul> \n<blockquote> \n <pre><code>1. 前置通知\n    &lt;aop:before method=\"\" pointcut=\"\" pointcut-ref=\"\"/&gt;\n        method : 通知，及方法名\n        pointcut :切入点表达式，此表达式只能当前通知使用。\n        pointcut-ref ： 切入点引用，可以与其他通知共享切入点。\n    通知方法格式：public void myBefore(JoinPoint joinPoint){\n        参数1：org.aspectj.lang.JoinPoint  用于描述连接点（目标方法），获得目标方法名等\n\n2. 后置通知  目标方法后执行，获得返回值\n    &lt;aop:after-returning method=\"\" pointcut-ref=\"\" returning=\"\"/&gt;\n        returning 通知方法第二个参数的名称\n   通知方法格式：public void myAfterReturning(JoinPoint joinPoint,Object result){\n        参数1：连接点描述\n        参数2：类型Object，参数名 returning=\"result\" 配置的\n\n3. 异常通知  目标方法发生异常后\n    &lt;aop:after-throwing method=\"testException\" throwing=\"e\"\n    pointcut=\"execution(* com.anqi.testAop.ArithmeticCalculator.div(..))\"/&gt;\n        throwing 发生的异常\n   通知方法格式：public Object testRound(ProceedingJoinPoint pjp){\n        参数1：ProceedingJoinPoint\n        返回值为 reslut</code></pre> \n</blockquote> \n<p><br></p> \n<h3 id=\"基于-xml-的配置方式\">4. 基于 xml 的配置方式</h3> \n<p>xml 配置文件<br> </p> \n<pre><code>&lt;context:component-scan base-package=\"com.anqi\"&gt;\n    &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;\n&lt;/context:component-scan&gt;\n&lt;!--1、 创建目标类 --&gt;\n&lt;bean id=\"arithmeticCalculator\" class=\"com.anqi.testAop.ArithmeticCalculatorImpl\"&gt;&lt;/bean&gt;\n&lt;!--2、创建切面类（通知）  --&gt;\n&lt;bean id=\"logAspect\" class=\"com.anqi.testAop.MyLogger\"&gt;&lt;/bean&gt;\n&lt;aop:config&gt;\n    &lt;aop:aspect ref=\"logAspect\"&gt;\n        &lt;!-- 切入点表达式 也可以在通知内部分别设置切入点表达式 --&gt;\n        &lt;aop:pointcut expression=\"execution(* com.anqi.testAop.*.*(..))\" id=\"myPointCut\"/&gt;\n        &lt;!-- 配置前置通知，注意 method 的值要和 对应切面的类方法名称相同 --&gt;\n        &lt;aop:before method=\"before\" pointcut-ref=\"myPointCut\" /&gt;\n        &lt;aop:after method=\"after\" pointcut-ref=\"myPointCut\" /&gt;\n        &lt;aop:after-returning method=\"testAfterReturn\" returning=\"result\" pointcut-ref=\"myPointCut\"/&gt;\n        &lt;aop:after-throwing method=\"testException\" throwing=\"e\" pointcut=\"execution(* com.anqi.testAop.ArithmeticCalculator.div(..))\"/&gt;\n        &lt;!--&lt;aop:around method=\"testRound\"  pointcut-ref=\"myPointCut\"  /&gt; 最强大，但是一般不使用--&gt;\n    &lt;/aop:aspect&gt;\n&lt;/aop:config&gt;</code></pre> \n<p><br> </p> \n<p>目标类</p> \n<pre class=\"java\"><code>public interface ArithmeticCalculator {\n    int add(int i, int j);\n    int sub(int i, int j);\n\n    int mul(int i, int j);\n    int div(int i, int j);\n}\n\npublic class ArithmeticCalculatorImpl implements ArithmeticCalculator {\n    @Override\n    public int add(int i, int j) {\n        int result = i + j;\n        return result;\n    }\n\n    @Override\n    public int sub(int i, int j) {\n        int result = i - j;\n        return result;\n    }\n\n    @Override\n    public int mul(int i, int j) {\n        int result = i * j;\n        return result;\n    }\n\n    @Override\n    public int div(int i, int j) {\n        int result = i / j;\n        return result;\n    }\n}</code></pre> \n<p><br><br> 切面类</p> \n<pre class=\"java\"><code>import org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport java.util.Arrays;\n\n/**\n * 创建日志类\n */\npublic class MyLogger {\n\n    public void before(JoinPoint joinPoint) {\n        System.out.println(\"前置通知 参数为[\"+joinPoint.getArgs()[0]+\",\"+joinPoint.getArgs()[1]+\"]\");\n    }\n    public void after(JoinPoint joinPoint) {\n        System.out.println(\"后置通知 \"+ joinPoint.getSignature().getName());\n    }\n\n    public void testException(JoinPoint joinPoint, Throwable e) {\n        System.out.println(\"抛出异常: \"+ e.getMessage());\n    }\n\n    public void testAfterReturn(JoinPoint joinPoint, Object result) {\n        System.out.println(\"返回通知，返回值为 \" + result);\n    }\n\n    public Object testRound(ProceedingJoinPoint pjp) {\n        Object result = null;\n        String methodName = pjp.getSignature().getName();\n        Object[] args = pjp.getArgs();\n        try {\n            //前置通知\n            System.out.println(\"!!!前置通知 --&gt; The Method\"+methodName+\" begins\"+ Arrays.asList(args));\n            //执行目标方法\n            result = pjp.proceed();\n            //返回通知\n            System.out.println(\"!!!返回通知 --&gt; The Method\"+methodName+\" ends\"+ args);\n\n        }catch(Throwable e) {\n            //异常通知\n            System.out.println(\"!!!异常通知 --&gt; The Method\"+methodName+\" ends with\"+ result);\n        }\n        //后置通知\n        System.out.println(\"!!!后置通知 --&gt; The Method\"+methodName+\" ends\"+ args);\n        return result;\n    }\n}</code></pre> \n<p><br><br> 测试</p> \n<pre class=\"java\"><code>import org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\npublic class Main {\n    public static void main(String[] args) {\n        ApplicationContext application = new ClassPathXmlApplicationContext(\"spring-context.xml\");\n        ArithmeticCalculator a = application.getBean(ArithmeticCalculator.class);\n        int result = a.add(1,2);\n        System.out.println(result);\n        System.out.println(a.div(5,0));\n    }\n}\n/*\n    前置通知 参数为[1,2]\n    后置通知 add\n    返回通知，返回值为 3\n    3\n    前置通知 参数为[5,0]\n    后置通知 div\n    抛出异常: / by zero\n*/</code></pre> \n<h3 id=\"基于注解的配置方式\">5. 基于注解的配置方式</h3> \n<p>xml</p> \n<pre class=\"xml\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;\n\n    &lt;context:component-scan base-package=\"com.anqi\"&gt;\n        &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;\n    &lt;/context:component-scan&gt;\n    &lt;!-- 使 AspectJ 注解起作用: 自动为匹配的类生成代理对象 --&gt;\n    &lt;aop:aspectj-autoproxy/&gt;\n&lt;/beans&gt;</code></pre> \n<p><br><br> 目标类</p> \n<pre class=\"java\"><code>public interface ArithmeticCalculator {\n    int add(int i, int j);\n    int sub(int i, int j);\n\n    int mul(int i, int j);\n    int div(int i, int j);\n}\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class ArithmeticCalculatorImpl implements ArithmeticCalculator {\n    @Override\n    public int add(int i, int j) {\n        int result = i + j;\n        return result;\n    }\n\n    @Override\n    public int sub(int i, int j) {\n        int result = i - j;\n        return result;\n    }\n\n    @Override\n    public int mul(int i, int j) {\n        int result = i * j;\n        return result;\n    }\n\n    @Override\n    public int div(int i, int j) {\n        int result = i / j;\n        return result;\n    }\n}</code></pre> \n<p><br><br> 切面</p> \n<pre class=\"java\"><code>import org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.*;\nimport org.springframework.stereotype.Component;\nimport java.util.Arrays;\n\n/**\n * 创建日志类\n */\n@Aspect\n@Component\npublic class MyLogger {\n\n    @Before(\"execution(* com.anqi.testAop.*.*(..))\")\n    public void before(JoinPoint joinPoint) {\n        System.out.println(\"前置通知 参数为[\"+joinPoint.getArgs()[0]+\",\"+joinPoint.getArgs()[1]+\"]\");\n    }\n    @After(\"execution(* com.anqi.testAop.*.*(..))\")\n    public void after(JoinPoint joinPoint) {\n        System.out.println(\"后置通知 \"+ joinPoint.getSignature().getName());\n    }\n\n    @AfterThrowing(value=\"execution(* com.anqi.testAop.ArithmeticCalculator.div(..))\", throwing = \"e\")\n    public void testException(JoinPoint joinPoint, Throwable e) {\n        System.out.println(\"抛出异常: \"+ e.getMessage());\n    }\n\n    @AfterReturning(value=\"execution(* com.anqi.testAop.*.*(..))\", returning = \"result\")\n    public void testAfterReturn(JoinPoint joinPoint, Object result) {\n        System.out.println(\"返回通知，返回值为 \" + result);\n    }\n\n    @Around(\"execution(* com.anqi.testAop.*.*(..))\")\n    public Object testRound(ProceedingJoinPoint pjp) {\n        Object result = null;\n        String methodName = pjp.getSignature().getName();\n        Object[] args = pjp.getArgs();\n        try {\n            //前置通知\n            System.out.println(\"!!!前置通知 --&gt; The Method\"+methodName+\" begins\"+ Arrays.asList(args));\n            //执行目标方法\n            result = pjp.proceed();\n            //返回通知\n            System.out.println(\"!!!返回通知 --&gt; The Method\"+methodName+\" ends\"+ args);\n\n        }catch(Throwable e) {\n            //异常通知\n            System.out.println(\"!!!异常通知 --&gt; The Method\"+methodName+\" ends with\"+ result);\n        }\n        //后置通知\n        System.out.println(\"!!!后置通知 --&gt; The Method\"+methodName+\" ends\"+ args);\n        return result;\n    }\n}\n</code></pre> \n<p><br><br> 输出结果与第一种方式一致，这里就不再赘述了。</p> \n<h3 id=\"切面的优先级\">6. 切面的优先级</h3> \n<p><br><br> 可以使用@Order来指定切面的优先级</p> \n<pre class=\"java\"><code>//参数验证切面\n@Order(1)\n@Aspect\n@Component\npublic class ValidateAspect {\n\n@Before(\"execution(public int com.anqi.spring.aop.order.ArithmeticCalculator.*(int, int))\")\npublic void validateArgs(JoinPoint join) {\n    String methodName = join.getSignature().getName();\n    Object[] args = join.getArgs();\n    System.out.println(\"validate\"+methodName+Arrays.asList(args));\n    }\n}\n\n//把这个类声明为一个切面：需要把该类放入到 IOC 容器中, 再声明为一个切面\n@Order(2)\n@Aspect\n@Component\npublic class LoggingAspect2 {\n\n/**\n * 声明该方法是一个前置通知: 在目标方法开始之前执行\n * @param join\n */\n@Before(\"execution(public int com.anqi.spring.aop.order.ArithmeticCalculator.*(int, int))\")\npublic void beforeMehod(JoinPoint join) {\n    String methodName = join.getSignature().getName();\n    List&lt;Object&gt; args = Arrays.asList(join.getArgs());\n    System.out.println(\"前置通知 --&gt; The Method\"+methodName+\" begins\"+ args);\n    }\n}</code></pre> \n<h3 id=\"重用切点表达式\">7. 重用切点表达式</h3> \n<pre class=\"java\"><code>//把这个类声明为一个切面：需要把该类放入到 IOC 容器中, 再声明为一个切面\n@Order(2)\n@Aspect\n@Component\npublic class LoggingAspect {\n\n    /**\n     * 定义一个方法, 用于声明切入点表达式, 一般地, 该方法中再不需要填入其他代码\n     */\n    @Pointcut(\"execution(public int com.anqi.spring.aop.order.ArithmeticCalculator.*(int, int))\")\n    public void declareJointPointExpression() {}\n\n\n    /**\n     * 声明该方法是一个前置通知: 在目标方法开始之前执行\n     * @param join\n     */\n    @Before(\"declareJointPointExpression()\")\n    public void beforeMehod(JoinPoint join) {\n        String methodName = join.getSignature().getName();\n        List&lt;Object&gt; args = Arrays.asList(join.getArgs());\n        System.out.println(\"前置通知 --&gt; The Method\"+methodName+\" begins\"+ args);\n    }\n}</code></pre> \n<p><br></p> \n<h3 id=\"两种方式的比较摘自-spring-官方文档\">8. 两种方式的比较（摘自 spring 官方文档）</h3> \n<p><br><br> 如果您选择使用Spring AOP，则可以选择@AspectJ或XML样式。需要考虑各种权衡。</p> \n<p>XML样式可能是现有Spring用户最熟悉的，并且由真正的POJO支持。当使用AOP作为配置企业服务的工具时，XML可能是一个不错的选择（一个好的测试是你是否认为切入点表达式是你可能想要独立改变的配置的一部分）。使用XML样式，从您的配置可以更清楚地了解系统中存在哪些方面。</p> \n<p>XML风格有两个缺点。首先，它没有完全封装它在一个地方解决的要求的实现。DRY原则规定，系统中的任何知识都应该有单一，明确，权威的表示。使用XML样式时，有关如何实现需求的知识将分支到支持bean类的声明和配置文件中的XML。使用@AspectJ样式时，此信息封装在单个模块中：方面。其次，XML样式在它所表达的内容方面比@AspectJ样式稍微受限：仅支持“单例”方面实例化模型，并且不可能组合在XML中声明的命名切入点。例如，</p> \n<pre class=\"java\"><code>@Pointcut(\"execution(* get*())\")\npublic void propertyAccess() {}\n\n@Pointcut(\"execution(org.xyz.Account+ *(..))\")\npublic void operationReturningAnAccount() {}\n\n@Pointcut(\"propertyAccess() &amp;&amp; operationReturningAnAccount()\")\npublic void accountPropertyAccess() {}</code></pre> \n<p>在XML样式中，您可以声明前两个切入点：</p> \n<pre class=\"xml\"><code>&lt;aop:pointcut id=\"propertyAccess\"\n        expression=\"execution(* get*())\"/&gt;\n\n&lt;aop:pointcut id=\"operationReturningAnAccount\"\n        expression=\"execution(org.xyz.Account+ *(..))\"/&gt;</code></pre> \n<p>XML方法的缺点是您无法 accountPropertyAccess通过组合这些定义来定义切入点。</p> \n<p>@AspectJ 样式支持额外的实例化模型和更丰富的切入点组合。它具有将方面保持为模块化单元的优点。它还具有以下优点：Spring AOP 和 AspectJ 都可以理解（并因此消耗）@AspectJ 方面。因此，如果您以后决定需要 AspectJ 的功能来实现其他要求，则可以轻松迁移到基于 AspectJ 的方法。总而言之，只要您的方面不仅仅是简单的企业服务配置，Spring 团队更喜欢 @AspectJ 风格。</p>', '2019-01-03 17:08:00', 'https://www.cnblogs.com/haixiang/p/10213729.html');
INSERT INTO `t_blog` VALUES ('17', '使用RAP2和Mock.JS实现Web API接口的数据模拟和测试', '<p>最近一直在思考如何对Web API的其接口数据进行独立开发的问题，随着Web API的越来越广泛应用，很多开发也要求前端后端分离，例如统一的Web API接口后，Winform团队、Web前端团队、微信小程序或者APP团队大家可以同步开发，在最初约定一些接口的输入JSON数据和输出JSON数据，但是随着项目的进度开展，这些数据结构一直有所变化，那么我们模拟的JSON数据格式也需要协同变化，但是很不幸既然大家忙着开发，接口协调的事情肯定优先级没那么高，即使每次记得协调接口数据，也不一定能够完全一致。</p> \n<p>在Web API端也就是后端没有完全做好的情况下，我们不可能给出所有接口的输入输出JSON格式，那么我们是否可以考虑采用折中模拟数据接口的方式来提供，并且能够提供比较易读、易维护的处理方式呢？答案是肯定有的，结合RAP2和Mock.js两者的特点，可以较为方便的模拟出我们需要接口的URL、输入参数、输出参数等信息。</p> \n<p>RAP2是一个Web接口管理工具，开源免费，接口自动化，MOCK数据自动生成，自动化测试，企业级管理。</p> \n<p>Mock.js的出现解决了前端离开后端就没法请求数据的问题，但也出现了新的问题，就是在切换生产环境的时候，模拟的数据可能和接口又发生不同步的情况。</p> \n<p>RAP2是一个新的解决方案，将前端后端拉倒一个团队仓库中，共享一个仓库，无论是URL地址，还是请求需要的参数，在团队仓库中双方都可以管理，并且可以记录团队成员修改了哪些接口，整合到生产环境的时候，可以比较完美的切换，同步性较好！</p> \n<p>相关网站资源：</p> \n<div> \n <div>\n  <a href=\"http://mockjs.com/\" rel=\"nofollow\" target=\"_blank\">http://mockjs.com/</a> mock.js网址\n  <br> \n  <a href=\"http://rap2.taobao.org/\" rel=\"nofollow\" target=\"_blank\">http://rap2.taobao.org/</a> RAP2网址\n  <br> \n  <a href=\"https://github.com/thx/rap2-delos\" rel=\"nofollow\" target=\"_blank\">https://github.com/thx/rap2-delos</a> RAP2官方文档\n  <br> \n  <a href=\"https://github.com/nuysoft/Mock/wiki/Syntax-Specification\" rel=\"nofollow\" target=\"_blank\">https://github.com/nuysoft/Mock/wiki/Syntax-Specification</a> mock.js语法规范文档\n </div> \n</div> \n<h3>1、RAP2创建接口</h3> \n<p>打开网站<a href=\"http://rap2.taobao.org/\" target=\"_blank\">http://rap2.taobao.org/ </a>，注册一个用户账号，并创建自己的模块和接口，如下所示</p> \n<p><img src=\"null2019/01/03/e8b52cd0-5460-4b28-a782-11c452719486.png\" alt=\"\"></p> \n<p>默认有一个示例接口指引我们做相关的参数或者响应内容</p> \n<p>对每个参数，都可以使用Mock规则进行生成值，如下界面所示</p> \n<p><img src=\"null2019/01/03/106a6b11-b075-4180-8bf0-285a69e7b1f3.png\" alt=\"\"></p> \n<p>除了示例，我们也可以创建自己的模块和接口，如下所示我们创建一个用户管理的模块，以及两个接口。</p> \n<p>获取用户的接口定义如下所示。</p> \n<p><img src=\"null2019/01/03/16d01e5f-6179-4b11-a472-b21ebc583658.png\" alt=\"\"></p> \n<p>这个URL地址是我们逻辑上的相对地址，实际在使用的时候，我们加上一个基地址就可以了，在RAP2 它也是一个相对地址，测试接口的地址也是加上一个基础地址，这样我们实际开发的时候，把这部分基础地址替换为生产环境的地址即可顺利切换过去了。</p> \n<p><img src=\"null2019/01/03/3cb7c532-75be-40ee-adb6-c25cc6d2d31e.png\" alt=\"\"></p> \n<p>这个接口实际返回的JSON数据格式就是我们约定好的JSON格式了，如果我们有变化，大家参考这个中间的平台就可以了，沟通时比较方便，也可以对比那些字段参数变化调整了，这样前后端就有了一个参考的中间平台，一致性较好。</p> \n<p>&nbsp;</p> \n<h3>2、接口参数定义和Mock变量使用</h3> \n<p>那么这些JSON数据是如何来的，我们其实是填写了一些变量，让它自动生成的数据的，这个也是Mock.js的功劳吧。RAP2集成了MockJS的很多变量使用，参考着使用就可以构建很多不一样的数据，非常方便。</p> \n<p>下面列出我的一些输入、输入的变量内容。</p> \n<p>输入的参数，定义如下：</p> \n<p><img src=\"null2019/01/03/7093ef7d-aba9-4f62-aabe-ad723135bfaf.png\" alt=\"\"></p> \n<p>响应的输出参数如下定义。</p> \n<p><img src=\"null2019/01/03/2716e459-ab7a-44e0-b9d0-3420962ede46.png\" alt=\"\"></p> \n<p>获得的输出自动生成的JSON数据如下所示。</p> \n<p><img src=\"null2019/01/03/a74c8341-a80c-4e2c-8dd7-cac005bb2ee2.png\" alt=\"\"></p> \n<p>这个就是我们使用Mock变量的好处，自动根据规则填充，上面我使用了各种变量来定义数据，如果你需要了解Mock的变量，可以结合Mock的变量来测试即可。具体参考下面说明。</p> \n<p><a href=\"http://mockjs.com/examples.html\" target=\"_blank\">http://mockjs.com/examples.html</a></p> \n<p>上面链接列出了Mock的两项定义：数据模板定义和数据占位符定义，可以根据情况用不同的定义。我更侧向于使用后者，方便快捷。</p> \n<p>RAP2给前后端开发者一种更好更透明的协同开发方式，一个负责维护接口、一个负责参考修改调用，大家相互配合，其乐融融。<br>关于RAP2的功能好像还有很多，不过我们使用它最主要的目的是解决模拟API接口和协同性的问题，这个大原则是它的主要目的，基于RAP2和Mock.js的结合，我们可以解放频繁沟通而得不到接口一致性问题的问题，从而实现更好从调试环境到生产环境的切换。</p> \n<p>甚至更好的方案是我们 在Web API接口开发的初期，先花点功夫来定义好所有的接口输入输出，整理一个大家认为比较好的接口规范后，再开始Web API的编码，这样肯定后期开发是事半功倍，而且前端也可以很快对接。</p> \n<div>\n &nbsp;\n</div>', '2019-01-03 17:08:08', 'https://www.cnblogs.com/wuhuacong/p/10213540.html');
INSERT INTO `t_blog` VALUES ('18', '中小研发团队架构实践之生产环境诊断工具WinDbg', '<p class=\"ql-text-indent-1 ql-long-3423802\">生产环境偶尔会出现一些异常问题，WinDbg或GDB是解决此类问题的利器。调试工具WinDbg如同医生的听诊器，是系统生病时做问题诊断的逆向分析工具，Dump文件类似于飞机的黑匣子，记录着生产环境程序运行的状态。本文主要介绍了调试工具WinDbg和抓包工具ProcDump的使用，并分享一个真实的案例。N年前不知谁写的代码，导致每一两个月偶尔出现CPU飙高的现象。我们先使用ProcDump在生产环境中抓取异常进程的Dump文件，然后在不了解代码的情况下通过WinDbg命令进行分析，最终定位到有问题的那行代码。</p> \n<div class=\"ql-long-3423802\" data-header=\"2\">\n <strong>一、诊断工具简介</strong>\n</div> \n<div class=\"ql-long-3423802\" data-header=\"3\">\n <strong>1.1 WinDbg</strong>\n</div> \n<p class=\"ql-text-indent-1 ql-long-3423802\">WinDbg是在Windows平台下的、强大的用户态和内核态调试工具。相比较于Visual Studio，它是一个轻量级的调试工具，所谓轻量级指的是它的安装文件大小较小，但是其调试功能，却比VS更为强大。它的另外一个用途是可以用来分析Dump数据。WinDbg是Microsoft公司免费调试器调试集合中的GUI的调试器，支持Source和Assembly两种模式的调试。WinDbg不仅可以调试应用程序，还可以进行Kernel Debug。结合Microsoft的Symbol Server，可以获取系统符号文件，便于应用程序和内核的调试。WinDbg支持的平台包括x86、IA64、AMD64。虽然WinDbg也提供图形界面操作，但它最强大的地方还是有着强大的调试命令，一般情况会结合GUI和命令行进行操作，常用的视图有：局部变量、全局变量、调用栈、线程、命令、寄存器、白板等。其中“命令”视图是默认打开的。</p> \n<div class=\"ql-long-3423802\" data-header=\"3\">\n <strong>1.2 DebugDiag</strong>\n</div> \n<p class=\"ql-text-indent-1 ql-long-3423802\">DebugDiag最初是为了帮助分析IIS的性能问题而开发的，它同样可以用于任何其他的进程。DebugDiag工具主要用于帮助解决如挂起、 速度慢、 内存泄漏或内存碎片，和任何用户模式进程崩溃等问题。该工具包括附加调试脚本，侧重于互联网信息服务（IIS）应用程序、 Web数据访问组件、 COM+和相关Microsoft技术、SharePoint和.NET。它提供可扩展对象模型中的COM对象的形式，并具有一个内置的报告框架提供的脚本主机。它由3 部分组成，包括调试服务、 调试器主机和用户界面。</p> \n<div class=\"ql-long-3423802\" data-header=\"3\">\n <strong>1.3 ProcDump</strong>\n</div> \n<p class=\"ql-text-indent-1 ql-long-3423802\">ProcDump是System Internal提供的一个专门用来监测程序CPU高使用率从而生成进程Dump文件的工具。ProcDump可以根据系统的CPU使用率或者指定的性能计数器来针对特定进程生成一系列的Dump文件，以便调试者对事故原因进行分析。</p> \n<div class=\"ql-long-3423802\" data-header=\"2\">\n <strong>二、诊断工具下载</strong>\n</div> \n<ul class=\"ql-long-3423802\" data-list-style=\"circle\"> \n <li class=\"bullet-item ql-long-3423802\" data-bullet-id=\"Nurp\"><strong>WinDbg x86位版本下载：</strong>【<a href=\"http://download.microsoft.com/download/A/6/A/A6AC035D-DA3F-4F0C-ADA4-37C8E5D34E3D/setup/WinSDKDebuggingTools/dbg_x86.msi\" target=\"_blank\">http://download.microsoft.com/download/A/6/A/A6AC035D-DA3F-4F0C-ADA4-37C8E5D34E3D/setup/WinSDKDebuggingTools/dbg_x86.msi</a>】</li> \n</ul> \n<ul class=\"ql-long-3423802\" data-list-style=\"circle\"> \n <li class=\"bullet-item ql-long-3423802\" data-bullet-id=\"Nurp\"><strong>WinDbg x64位版本下载：</strong>【<a href=\"http://download.microsoft.com/download/A/6/A/A6AC035D-DA3F-4F0C-ADA4-37C8E5D34E3D/setup/WinSDKDebuggingTools_amd64/dbg_amd64.msi\" target=\"_blank\">http://download.microsoft.com/download/A/6/A/A6AC035D-DA3F-4F0C-ADA4-37C8E5D34E3D/setup/WinSDKDebuggingTools_amd64/dbg_amd64.msi</a>】</li> \n</ul> \n<ul class=\"ql-long-3423802\" data-list-style=\"circle\"> \n <li class=\"bullet-item ql-long-3423802\" data-bullet-id=\"Nurp\"><strong>DebugDiag v2下载：</strong>【<a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=49924\" target=\"_blank\">https://www.microsoft.com/en-us/download/details.aspx?id=49924</a>】</li> \n</ul> \n<ul class=\"ql-long-3423802\" data-list-style=\"circle\"> \n <li class=\"bullet-item ql-long-3423802\" data-bullet-id=\"Nurp\"><strong>ProcDump v9.0下载：</strong>【<a href=\"https://download.sysinternals.com/files/Procdump.zip\" target=\"_blank\">https://download.sysinternals.com/files/Procdump.zip</a>】</li> \n</ul> \n<div class=\"ql-long-3423802\" data-header=\"2\">\n <strong>三、获取异常进程的Dump文件</strong>\n</div> \n<p class=\"ql-long-3423802\">有以下四种方式获取Dump文件，具体如下：</p> \n<div class=\"ql-long-3423802\" data-header=\"3\">\n <strong>3.1 通过【任务管理器】获取Dump文件，这样获取的是MinDump</strong>\n</div> \n<p class=\"ql-long-3423802\"><img src=\"null2019/01/03/a3d22aa0-2dbd-4ac4-a01c-ae82c6956ee8.jpeg\" alt=\"\" width=\"612px\" height=\"403.672px\"></p> \n<div class=\"ql-long-3423802\" data-header=\"3\">\n <strong>3.2 利用WinDbg的adplus获取Dump文件，这样获取的是FullDump</strong>\n</div> \n<p class=\"ql-long-3423802\"><img src=\"null2019/01/03/532f0fb5-cb3e-4c5f-b956-5cd66cc496b3.jpeg\" alt=\"\" width=\"612px\" height=\"490.734px\"></p> \n<div class=\"ql-long-3423802\" data-header=\"3\">\n <strong>3.3&nbsp;通过DebugDiag创建.NET异常转储Dump文件</strong>\n</div> \n<p class=\"ql-long-3423802\"><img src=\"null2019/01/03/913e6232-2590-47ad-bd7d-8ba30a985d04.gif\" alt=\"\" width=\"447px\" height=\"362px\"></p> \n<p class=\"ql-long-3423802\"><img src=\"null2019/01/03/4b1e9137-b63a-4119-9e55-d4ad279a12c2.jpeg\" alt=\"\" width=\"462px\" height=\"369px\"></p> \n<div class=\"ql-long-3423802\" data-header=\"3\">\n <strong>3.4 通过ProcDump抓取异常线程Dump文件</strong>\n</div> \n<p class=\"ql-long-3423802\">现在重点介绍通过ProcDump抓取异常线程Dump文件，使用方法如下：</p> \n<div class=\"ql-long-3423802\" data-header=\"3\">\n <strong>a. 命令行：</strong>\n</div> \n<pre>procdump [-a] [[-c|-cl CPU usage] [-u] [-s seconds]] [-n exceeds] [-e [1 [-b]] [-f &lt;filter,...&gt;] [-g] [-h] [-l] [-m|-ml commit usage] [-ma | -mp] [-o] [-p|-pl counter threshold] [-r] [-t] [-d &lt;callback DLL&gt;] [-64] &lt;[-w] &lt;process name or service name or PID&gt; [dump file] | -i &lt;dump file&gt; | -u | -x &lt;dump file&gt; &lt;image file&gt; [arguments] &gt;] [-? [ -e]</pre> \n<div class=\"ql-long-3423802 ql-authorBlock-3423802\" data-header=\"3\">\n b. 实例：\n</div> \n<p class=\"ql-long-3423802\"><strong>procdump -c 70 -s 5 -ma -n 3 w3wp</strong></p> \n<p class=\"ql-long-3423802\">当系统CPU使用率持续5秒超过70%时，连续抓3个Full Dump。</p> \n<p class=\"ql-long-3423802\"><strong>procdump outlook -p \"\\Processor(_Total)\\% Processor Time\" 80</strong></p> \n<p class=\"ql-long-3423802\">当系统CPU使用率超过80%，抓取Outlook进程的Mini Dump。</p> \n<p class=\"ql-long-3423802\"><strong>procdump -ma outlook -p \"\\Process(Outlook)\\Handle Count\" 10000</strong></p> \n<p class=\"ql-long-3423802\">当Outlook进程Handle数超过10000时抓取Full Dump</p> \n<p class=\"ql-long-3423802\"><strong>procdump -ma 4572</strong></p> \n<p class=\"ql-long-3423802\">直接生成进程号为4572的Full Dump。</p> \n<p class=\"ql-long-3423802\"><strong>&nbsp;</strong></p> \n<p class=\"ql-long-3423802\">下图是在WindgbHighCpu进程中造成High CPU时运行ProcDump命令的运行效果，可以看到在CPU每次持续5秒达到5%后就会生成相应的Dump文件，共生成了3份Full Dump文件：</p> \n<p class=\"ql-long-3423802\"><img src=\"null2019/01/03/b2cca2ca-9460-436d-b295-efaa98c5fb2a.jpeg\" alt=\"\" width=\"612px\" height=\"672.609px\"></p> \n<div class=\"ql-long-3423802\" data-header=\"3\">\n <strong>c. 注意：</strong>\n</div> \n<ul class=\"ql-long-3423802\" data-list-style=\"circle\"> \n <li class=\"bullet-item ql-long-3423802\" data-bullet-id=\"5Aqa\">ProcDump需要进程已经启动，并且中途不能停止。比如需要抓取IIS Worker Process的High CPU Dump，由于IIS Worker Process默认会配置Idle Timeout = 20 min，即该进程在20分钟内没有任何请求的话就会自动结束，这种情况下ProcDump也会自动结束。需要重新运行命令。因此如果目标程序存在这样的配置，需要暂时将该配置取消。</li> \n</ul> \n<ul class=\"ql-long-3423802\" data-list-style=\"circle\"> \n <li class=\"bullet-item ql-long-3423802\" data-bullet-id=\"5Aqa\">有些系统管理员希望能够运行该工具后退出用户session，ProcDump是做不到的，如果有这种需求可以考虑使用DebugDiag。</li> \n</ul> \n<ul class=\"ql-long-3423802\" data-list-style=\"circle\"> \n <li class=\"bullet-item ql-long-3423802\" data-bullet-id=\"5Aqa\">在调试High CPU问题的时候经常用到的一个命令是!runaway，但是有些时候!runway在ProcDump抓取Dump文件的过程中运行不出来，报错信息如下：</li> \n</ul> \n<pre>0:000&gt; !runaway ERROR: !runaway: extension exception 0x80004002. \"Unable to get thread times - dumps may not have time information\"</pre> \n<p class=\"ql-long-3423802\">解决的方法是将Debugging Tools for Windows (WinDbg)安装目录下的dbghelp.dll拷贝到procdump.exe所在目录下，然后再运行命令抓取Dump。&nbsp;</p> \n<div class=\"ql-long-3423802\" data-header=\"2\">\n <strong>四、WinDbg使用方法</strong>\n</div> \n<p class=\"ql-long-3423802\">操作步骤如下：</p> \n<div class=\"ql-long-3423802\" data-header=\"3\">\n <strong>4.1 抓取异常程序的Dump文件</strong>\n</div> \n<div class=\"ql-long-3423802\" data-header=\"3\">\n <strong>4.2 设置符号表</strong>\n</div> \n<p class=\"ql-long-3423802\">符号表是WinDbg关键的“数据库”，如果没有它，WinDbg基本上就是个废物，无法分析更多问题。所以使用WinDbg设置符号表，是必须要走的一步。</p> \n<p class=\"ql-long-3423802\">a、运行WinDbg软件，然后按【Ctrl+S】弹出符号表设置窗。</p> \n<p class=\"ql-long-3423802\">b、将符号表地址：<strong><em>SRV*</em></strong><strong><em>C:\\Symbols</em></strong><strong><em>*</em></strong><a href=\"http://msdl.microsoft.com/download/symbols\" target=\"_blank\"><strong><em>http://msdl.microsoft.com/download/symbols</em></strong></a>&nbsp;粘贴在输入框中，点击确定即可。点击确定之前，请先确认红色字的文件夹是否已被新建。</p> \n<p class=\"ql-long-3423802\">注：红色字表示符号表本地存储路径，建议固定路径，可避免符号表重复下载。</p> \n<div class=\"ql-long-3423802\" data-header=\"3\">\n <strong>4.3 学会打开第一个Dump文件</strong>\n</div> \n<p class=\"ql-long-3423802\"><img src=\"null2019/01/03/626aeee4-18da-4aa3-8689-de386d02ea61.jpeg\" alt=\"\" width=\"309px\" height=\"196px\"></p> \n<p class=\"ql-long-3423802\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> \n<p class=\"ql-long-3423802\"><img src=\"null2019/01/03/ae28555b-abce-4bce-a7e4-0ae5e60ba471.png\" alt=\"\" width=\"315px\" height=\"136px\"></p> \n<p>&nbsp;</p> \n<p class=\"ql-text-indent-1 ql-long-3423802\">当你拿到一个Dump文件后，可使用<strong>【Ctrl+D】</strong>快捷键来打开一个Dump文件，或者点击WinDbg界面上的<strong>【File=&gt;Open Crash Dump...】</strong>按钮，来打开一个Dump文件。第一次打开Dump文件时，可能会收到如下提示，出现这个提示时，勾选“Don\'t ask again in this WinDbg session”，然后点否即可。</p> \n<p class=\"ql-text-indent-1 ql-long-3423802\">当你想打开第二个Dump文件时，可能因为上一个分析记录未清除，导致无法直接分析下一个Dump文件，此时你可以使用快捷键【<strong>Shift+F5</strong>】来关闭上一个对Dump文件的分析记录。</p> \n<div class=\"ql-long-3423802\" data-header=\"3\">\n <strong>4.4 通过简单的几个命令学会分析Dump文件</strong>\n</div> \n<p class=\"ql-long-3423802\"><strong>分享一个数据库连接超时的Dump案例的分析过程：</strong></p> \n<p class=\"ql-long-3423802\">当你打开一个Dump文件后，可能因为太多信息，让你无所适从，不过没关系，我们只需要关注几个关键信息就可以了。</p> \n<div class=\"ql-long-3423802\" data-header=\"3\">\n <strong>a. 加载SOS扩展命令</strong>\n</div> \n<p class=\"ql-long-3423802\">加载SOS之前，先确定SOS的位置和版本，确定方法如下：</p> \n<p class=\"ql-long-3423802\">如果安装了Visual Studio，那么先按照如下步骤打开VS的命令行：</p> \n<p class=\"ql-long-3423802\"><img src=\"null2019/01/03/ed2fd0c5-48e5-4055-9302-86a19371d72a.png\" alt=\"\" width=\"230px\" height=\"111px\"></p> \n<p class=\"ql-long-3423802\"><img src=\"null2019/01/03/591e0366-214b-464c-8bb4-8572915b266c.png\" alt=\"\" width=\"612px\" height=\"407.703px\"></p> \n<p class=\"ql-long-3423802\">然后，在打开的VS命令行中输入【where sos.dll】，使获得SOS的位置和版本：</p> \n<p class=\"ql-long-3423802\"><img src=\"null2019/01/03/7568f18e-4c73-46e6-ae51-4809aa8b65f4.png\" alt=\"\" width=\"565px\" height=\"90px\"></p> \n<p class=\"ql-long-3423802\">&nbsp;</p> \n<p class=\"ql-long-3423802\">确定完SOS位置和版本号后，开始加载SOS扩展命令：</p> \n<pre>.load C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\SOS.dll</pre> \n<p class=\"ql-long-3423802\">如下图所示：</p> \n<p class=\"ql-long-3423802\"><img src=\"null2019/01/03/b11b834b-f557-44f6-863d-b821fc8d32f6.jpeg\" alt=\"\" width=\"612px\" height=\"300.688px\"></p> \n<div class=\"ql-long-3423802\" data-header=\"3\">\n <strong>b. 使用!clrstack命令来查看当前的调用堆栈信息</strong>\n</div> \n<p class=\"ql-long-3423802\">如下图所示：</p> \n<p class=\"ql-long-3423802\"><img src=\"null2019/01/03/9fef30c6-31ef-4581-bb6d-e0c21f6eb23e.jpeg\" alt=\"\" width=\"612px\" height=\"351.188px\"></p> \n<div class=\"ql-long-3423802\" data-header=\"3\">\n <strong>c. 使用!dso命令来查看堆栈上的所有对象详细信息</strong>\n</div> \n<p class=\"ql-long-3423802\">如下图所示：</p> \n<p class=\"ql-long-3423802\"><img src=\"null2019/01/03/8852dde1-9aa6-427a-8f2a-f7b51d195abb.jpeg\" alt=\"\" width=\"612px\" height=\"278.469px\"></p> \n<p class=\"ql-long-3423802\">综合以上分析可以大胆地猜测Common.cs&nbsp;中第16行“Data Source=***;Initial Catalog=***;Persist Security Info=True;User ID=sa;Password=***”的这个数据库连接字符串应该有问题，然后到代码中相应的地方进一步确认和修改就可以了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> \n<div class=\"ql-long-3423802\" data-header=\"2\">\n <strong>五、一个真实案例</strong>\n</div> \n<p class=\"ql-long-3423802\">分享笔者工作过的一家公司某业务系统CPU飙高90%以上的Dump分析过程案例，步骤如下：</p> \n<div class=\"ql-long-3423802\" data-header=\"3\">\n <strong>5.1 使用ProcDump抓包</strong>\n</div> \n<div class=\"ql-long-3423802\" data-header=\"3\">\n <strong>5.2 加载SOS扩展命令</strong>\n</div> \n<pre>.load C:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727\\sos.dll</pre> \n<p class=\"ql-long-3423802\"><img src=\"null2019/01/03/f732b406-46dc-4e8d-ac04-51959bc9844b.jpeg\" alt=\"\" width=\"612px\" height=\"323.313px\"></p> \n<div class=\"ql-long-3423802\" data-header=\"3\">\n <strong>5.3 分析</strong>\n</div> \n<p class=\"ql-long-3423802\">执行!runaway命令，查看线程使用CPU时间情况，如下图所示。着重分析前面几个线程。&nbsp;</p> \n<p class=\"ql-long-3423802\"><img src=\"null2019/01/03/28abc01f-b6e0-434c-9fc9-fb40730eca41.jpeg\" alt=\"\" width=\"337px\" height=\"557px\"></p> \n<p class=\"ql-long-3423802\">执行~22s命令，进入到线程22，如下图所示：</p> \n<p class=\"ql-long-3423802\"><img src=\"null2019/01/03/9c05a3df-0b11-43b8-a5ef-d97047ded12a.jpeg\" alt=\"\" width=\"612px\" height=\"150.688px\"></p> \n<p class=\"ql-long-3423802\">执行!clrstack命令查看当前线程堆栈变量值的信息，从图中可以猜出大概是ExecuteNonQuery()这方法有点问题，如下图所示：</p> \n<p class=\"ql-long-3423802\"><img src=\"null2019/01/03/cd39b616-20e1-4c55-ac2b-50a2e2481de8.jpeg\" alt=\"\" width=\"612px\" height=\"306.297px\"></p> \n<p class=\"ql-long-3423802\">再执行!dso命令可以查看堆栈上的所有对象详细信息，如下图所示：</p> \n<p class=\"ql-long-3423802\"><img src=\"null2019/01/03/0f115a6a-7ad8-49b1-a5db-0c82b594757b.png\" alt=\"\" width=\"612px\" height=\"229.078px\"></p> \n<p class=\"ql-long-3423802\">从图中看，造成CPU飙高的罪魁祸首多半由SQL Server执行</p> \n<pre>INSERT INTO [dbo].[tbl_Interface_ProcessLog] (IKey,Username,ClientIP,Module,OrderNo,LogType,Content) VALUES (@IKey,@Username,@ClientIP,@Module,@OrderNo,@LogType,@Content)</pre> \n<p class=\"ql-long-3423802\">这条语句时产生异常引起，然后到源代码中找出相应的语句，经过进一步的确认、修改和重新发布后就解决了CPU飙高的问题。</p> \n<p>&nbsp;</p> \n<p class=\"ql-long-3423802\">至此，掌握几个简单的WinDbg命令之后，基本上绝大多数Dump大家都可以独立分析了。当然WinDbg是个强大的工具，同时产生CPU飙高和内存泄漏的原因也有很多。如果想分析得足够准确，那么就只有多学多练，多去分析。因为掌握WinDbg分析除了需要懂得几个命令之外，经验更加重要，最后再补充两点：</p> \n<ol class=\"ql-long-3423802\" data-list-style=\"decimal\"> \n <li class=\"ordered-item ql-long-3423802\" data-list-id=\"Q6cP\" data-list-number=\"1\" data-list-content=\"1.\">WinDbg不是专门用于调试.NET程序的工具，它更偏向于底层，可用于内核和驱动调试，特别是对于某些相当疑难的问题调试有所帮助，例如内存泄漏等问题。进行普通的.NET程序调试还是使用微软专为.NET开发所提供的调试工具更方便一些。</li> \n</ol>\n<ol class=\"ql-long-3423802\" data-list-style=\"decimal\"> \n <li class=\"ordered-item ql-long-3423802\" data-list-id=\"Q6cP\" data-list-number=\"2\" data-list-content=\"2.\">SOS扩展命令中最有用的命令是<strong>!help</strong>，使用该命令可以列出所有可用的SOS扩展命令列表，使用<strong>!help [SOSCommandName]</strong>可以查看每一个具体扩展命令的详细使用说明。例如!help dumpheap就可以查看!dumpheap这个扩展命令的具体使用方法。多多利用!help命令可以很快上手SOS。</li> \n</ol> \n<div class=\"ql-long-3423802\" data-header=\"2\">\n <strong>六、Demo下载及更多资料</strong>\n</div> \n<ul class=\"ql-long-3423802\" data-list-style=\"circle\"> \n <li class=\"bullet-item ql-long-3423802\" data-bullet-id=\"zidL\">WinDbgTest下载地址：<a href=\"https://github.com/das2017/WinDbgTest\" target=\"_blank\">https://github.com/das2017/WinDbgTest</a></li> \n</ul> \n<ul class=\"ql-long-3423802\" data-list-style=\"circle\"> \n <li class=\"bullet-item ql-long-3423802\" data-bullet-id=\"zidL\">WinDbg官网：<a href=\"http://www.windbg.org/\" target=\"_blank\">http://www.windbg.org/</a></li> \n</ul> \n<ul class=\"ql-long-3423802\" data-list-style=\"circle\"> \n <li class=\"bullet-item ql-long-3423802\" data-bullet-id=\"zidL\">ProcDump v9.0官网：<a href=\"https://technet.microsoft.com/en-us/sysinternals/dd996900.aspx\" target=\"_blank\">https://technet.microsoft.com/en-us/sysinternals/dd996900.aspx</a></li> \n</ul>', '2019-01-03 17:08:27', 'https://www.cnblogs.com/dotnet-arch-system/p/10213539.html');
INSERT INTO `t_blog` VALUES ('19', '状态的抽象：从狼羊白菜游戏和倒油问题说起', '<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:sql;gutter:true;\">　　版权申明：本文为博主窗户(Colin Cai)原创，欢迎转帖。如要转贴，必须注明原文网址\r\n\r\n　　http://www.cnblogs.com/Colin-Cai/p/7507317.html \r\n\r\n　　作者：窗户\r\n\r\n　　QQ/微信：6679072\r\n\r\n　　E-mail：6679072@qq.com</pre> \n</div> \n<p>　　数学中有一个重要概念，就是抽象。由数学开始发展的计算机科学，自然也离不开抽象。计算机语言、编程范式都为抽象提供了工具，函数、回调、泛型、算子、类……</p> \n<p>　　以下从两个问题开始，描述了一大类抽象。</p> \n<p>&nbsp;</p> \n<p><strong><span style=\"font-size: 18pt;\">问题</span></strong></p> \n<p>&nbsp;</p> \n<p>　　这一篇文章我们先引入两个问题。</p> \n<p>　　</p> \n<p>　　<strong><span style=\"color: #ff0000;\">狼、羊、白菜问题</span></strong>：</p> \n<p>　　<span style=\"color: #993366;\">一个农夫带着一匹狼、一只羊、一筐白菜这三样东西，需要过一条河。河上有条船，农夫每次渡河要么是自己一个人，要么最多带三样东西中的其中一样，多带了船要沉。农夫当然是要把三样东西都带过河，但是有一个限制条件，如果农夫不在旁边，狼是要吃羊的，羊是要吃白菜的，这是要绝对避免的。农夫怎么一个过程，才能把狼、羊、白菜都运过河呢？</span></p> \n<p>&nbsp;</p> \n<p>　　<strong><span style=\"color: #ff0000;\">倒油问题</span></strong>：</p> \n<p>　　<span style=\"color: #993366;\">有两个没有刻度的杯子，一个杯子倒满是9升，另一个杯子倒满是4升。请问如何利用这两个杯子倒出6升油？</span></p> \n<p>&nbsp;</p> \n<p><strong><span style=\"font-size: 18pt;\">思考</span></strong></p> \n<p>&nbsp;</p> \n<p>　　这两道题目说来应该历史比较悠久。特别是第一道题目我印象非常深刻，在我小的时候就见过这个题目，当时我父亲拿着我的小船玩具和三颗不一样的扣子、药丸给我讲了这个问题的解答。</p> \n<p>　　我在这里之所以把这两个表面上看起来八竿子打不到一起的问题放在一起，自然是因为这两个问题实际上具有某些方面的一致性。而我们今天要讲的就是如何把这两个问题抽化从而提取共性，从更一般的角度上去解决这两个问题乃至更多的问题。</p> \n<p>　　一般来说，这样的题目会出现在孩子的奥数甚至脑筋急转弯里。然而，我从来不认为一把钥匙开一把锁从而满是套路的教育有什么真正的用处。</p> \n<p>&nbsp;</p> \n<p><strong><span style=\"font-size: 18pt;\">状态和原子</span></strong></p> \n<p>&nbsp;</p> \n<p>　　所谓<strong><span style=\"color: #ff0000;\">抽象</span></strong>，就是从各个问题中去掉不重要的成分，只保留与问题解答相关的最少信息，然后再从多个问题中提取共性。问题中不重要的成分很多，比如狼羊白菜问题中羊的种类、白菜的重量、农夫划船的速度，倒油问题中杯子的材质、倒油的速度，等等，此类信息都是与问题的解答没什么关系，都是不需要考虑的。</p> \n<p>　　然后就是提取共性。</p> \n<p>　　对于这两个问题，数学建模首先做的第一个抽象就是状态和原子。</p> \n<p>　　</p> \n<p>　　<strong><span style=\"color: #ff0000;\">我们把这两个问题都看成是状态的转换，而推动状态转换的是不可分割的原子操作。</span></strong></p> \n<p>　　对于狼羊白菜问题，过程中不断渡船改变的只是两岸的物品，可以认为状态是当前河两岸的物品（包括狼、羊、白菜，以及农夫），使用字母代替更加方便一点，狼用<span style=\"color: #993366;\">W</span>代替，羊用<span style=\"color: #993366;\">S</span>代替，白菜用<span style=\"color: #993366;\">C</span>代替，农夫用<span style=\"color: #993366;\">F</span>代替，那么最开始的状态为<strong><span style=\"color: #993366;\">FWSC||</span></strong>，如果第一步农夫带着羊渡船，之后的状态则为<strong><span style=\"color: #993366;\">WC||FS</span></strong>，其中两条竖线代表一条河应该比较形象化，当然，符号长什么样其实并不重要。</p> \n<p>　　然后我们把每次渡船看成原子操作，如果第一步农夫带着羊渡船，就记作<strong><span style=\"color: #993366;\">FS-&gt;</span></strong></p> \n<p>　　对于倒油问题，我们把9升的杯子称为A杯，把4升的杯子称为B杯。反复的倒来倒去改变的只是两个杯子的油量，从而可以认为状态是两个杯子的油量组成的序偶。比如<strong><span style=\"color: #993366;\">(5,4)</span></strong>就是A杯有5升油，B杯有4升油。</p> \n<p>　　原子操作则为每一次倒油，因为杯子没有刻度，我们可以想到的是：</p> \n<p>　　倒满A杯，记作<strong><span style=\"color: #993366;\">A&lt;-</span></strong>；</p> \n<p>　　倒满B杯，记作<strong><span style=\"color: #993366;\">B&lt;-</span></strong>；</p> \n<p>　　倒空A杯，记作<strong><span style=\"color: #993366;\">A-&gt;</span></strong>；</p> \n<p>　　倒空B杯，记作<strong><span style=\"color: #993366;\">B-&gt;</span></strong>；</p> \n<p>　　再者，A杯和B杯也可以互相倒，分别记作<strong><span style=\"color: #993366;\">A-&gt;B</span></strong>和<strong><span style=\"color: #993366;\">B-&gt;A</span></strong>，倒油直到一只杯子倒空或者另外一只杯子倒满为止。</p> \n<p>　　</p> \n<p>　　另外，再重申一次，<strong><span style=\"color: #ff0000;\">思想最重要，符号不重要！</span></strong>&nbsp;</p> \n<p>&nbsp;</p> \n<p><strong><span style=\"font-size: 18pt;\">图的遍历</span></strong></p> \n<p>&nbsp;</p> \n<p>　　有了上面状态和原子的抽象，就有了图的抽象，其中图的顶点就是各个状态，而图的边则为各个原子操作。</p> \n<p>　　而原问题就抽象为图的路径寻找问题，从而本质上还是图的遍历问题。</p> \n<p>&nbsp;</p> \n<p>&nbsp;　　<img src=\"null2019/01/03/1c87cb3d-a959-40ca-90e7-fbe2f88d77e7.jpeg\" alt=\"\"></p> \n<p>&nbsp;</p> \n<p>　　上图就是狼羊白菜问题的状态图，红线经过的是全部过河的最短路径。</p> \n<p>　　</p> \n<p>　　既然要讲遍历，还是以下面这个简单一点的图为例子比较好。</p> \n<p>　　<img src=\"null2019/01/03/c0a6f73f-fe93-47ba-9ca9-b3a12ddb850a.jpeg\" alt=\"\"></p> \n<p>&nbsp;</p> \n<p><span style=\"font-size: 18pt;\"><strong>广度遍历</strong></span></p> \n<p>&nbsp;</p> \n<p>　　为了找到达到目的状态的<strong><span style=\"color: #ff0000;\">最短路径</span></strong>，可以选择广度遍历。</p> \n<p>　　对于广度遍历，如果只是遍历出图的各个顶点，学过数据结构的应该都知道，只需要一个队列，先把最初的顶点入列，之后每次顶点出列之前先把该顶点直接指向的没有遍历过的顶点入队，如此重复直到队列为空。当然，我们需要记录已遍历过的顶点。</p> \n<p>　　对于上面的图，广度遍历队列的变换可能如下(每次都是入列和出列一起，右边一列记录当前已经遍历过的顶点)：</p> \n<p><span style=\"color: #800080;\">　　[1]&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {1}</span></p> \n<p><span style=\"color: #800080;\">　　[2 3 4]&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; {1,2,3,4}</span></p> \n<p><span style=\"color: #800080;\">　　[3 4 5]&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; {1,2,3,4,5}</span></p> \n<p><span style=\"color: #800080;\">　　[4 5]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;{1,2,3,4,5}</span></p> \n<p><span style=\"color: #800080;\">　　[5 6]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{1,2,3,4,5,6}</span></p> \n<p><span style=\"color: #800080;\">　　[6]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;{1,2,3,4,5,6}</span></p> \n<p><span style=\"color: #800080;\">　　[]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;{1,2,3,4,5,6}</span></p> \n<p>　　但是，我们不要忘了，我们目的是在搜索到合适的顶点时得到路径，而上述队列里没有任何路径的信息，从而队列里的每个元素只放顶点是不合适的，还要把顶点的路径也放在一起。比如上述如果要找到6并给出6的路径，应该是</p> \n<p><span style=\"color: #800080;\">　　[(1,)]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {1}</span></p> \n<p><span style=\"color: #800080;\">　　[(2,<span style=\"color: #00ccff;\">1</span>),(3,<span style=\"color: #00ccff;\">1</span>),(4,<span style=\"color: #00ccff;\">1</span>)]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1,2,3,4}</span></p> \n<p><span style=\"color: #800080;\">　　[(3,<span style=\"color: #00ccff;\">1</span>),(4,<span style=\"color: #00ccff;\">1</span>),(5,<span style=\"color: #00ccff;\">1-&gt;2</span>)]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {1,2,3,4,5}</span></p> \n<p><span style=\"color: #800080;\">　　[(4,<span style=\"color: #00ccff;\">1</span>),(5,<span style=\"color: #00ccff;\">1-&gt;2</span>)]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {1,2,3,4,5}</span></p> \n<p><span style=\"color: #800080;\">　　[(5,<span style=\"color: #00ccff;\">1-&gt;2</span>),(6,<span style=\"color: #00ccff;\">1-&gt;4</span>)]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1,2,3,4,5,6}</span></p> \n<p>　　如此，当找到6这个顶点的时候，会知道路径是1-&gt;4-&gt;6</p> \n<p>&nbsp;</p> \n<p><strong><span style=\"font-size: 18pt;\">深度遍历</span></strong></p> \n<p>&nbsp;</p> \n<p>　　深度遍历是另外一种遍历方法。深度遍历使用一个栈来记录压栈的路径，压栈是路径往前加一个顶点，而退栈是路径最前端减少一个节点。既然栈记录的是路径，而我们的目的是路径，那么我们至少不需要和广度遍历那样，对于每个顶点都再记录完整路径，因为从栈底到这个顶点就是路径。（但是我们实际需要的路径可能是过程中的原子操作，所以实际需求的时候也可以再做一个栈，用来压原子操作）</p> \n<p>　　大多数人会记得，深度遍历依然需要标志来记录已经遍历过的顶点。<strong><span style=\"color: #ff0000;\">实际上，这个不是必须的。</span></strong></p> \n<p>　　我们考虑一般情况的回溯，我们除了栈之外并没有这样的标志来记录以往遍历过的顶点，也就是遍历的过程中永远只知道栈里的顶点遍历过而需要规避，不过有一个重要信息，就是每次退栈回溯的时候我们会知道刚才退出的顶点，如果我们对于每个顶点，它所指向的所有的顶点存在一个排序，那么<strong><span style=\"color: #ff0000;\">回溯是可以终止的</span></strong>。</p> \n<p>　　对于上面的这个图，我们不记录以往遍历过的顶点回溯的过程如下：</p> \n<p><span style=\"color: #993366;\">　　[1]</span><br><span style=\"color: #993366;\">　　[1 2]</span><br><span style=\"color: #993366;\">　　[1 2 3]</span><br><span style=\"color: #993366;\">　　[1 2 3 4]</span><br><span style=\"color: #993366;\">　　[1 2 3 4 6]</span><br><span style=\"color: #993366;\">　　[1 2 3 4] (6)</span><br><span style=\"color: #993366;\">　　[1 2 3] (4)</span><br><span style=\"color: #993366;\">　　[1 2 3 6]</span><br><span style=\"color: #993366;\">　　[1 2 3] (6)</span><br><span style=\"color: #993366;\">　　[1 2] (3)</span><br><span style=\"color: #993366;\">　　[1 2 5]</span><br><span style=\"color: #993366;\">　　[1 2] (5)</span><br><span style=\"color: #993366;\">　　[1] (2)</span><br><span style=\"color: #993366;\">　　[1 3]</span><br><span style=\"color: #993366;\">　　[1 3 4]</span><br><span style=\"color: #993366;\">　　[1 3 4 6]</span><br><span style=\"color: #993366;\">　　[1 3 4] (6)</span><br><span style=\"color: #993366;\">　　[1 3] (4)</span><br><span style=\"color: #993366;\">　　[1 3 6]</span><br><span style=\"color: #993366;\">　　[1 3] (6)</span><br><span style=\"color: #993366;\">　　[1] (3)</span><br><span style=\"color: #993366;\">　　[1 4]</span><br><span style=\"color: #993366;\">　　[1 4 6]</span><br><span style=\"color: #993366;\">　　[1 4] (6)</span><br><span style=\"color: #993366;\">　　[1] (4)</span></p> \n<p>　　上面虽然可以完成遍历，但是顶点可能不只一次被遍历。</p> \n<p>　　于是，我们还是记录下节点访问标记，那么上图遍历则如下：</p> \n<p><span style=\"color: #993366;\">　　[1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}</span><br><span style=\"color: #993366;\">　　[1 2]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {1,2}</span><br><span style=\"color: #993366;\">　　[1 2 3]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1,2,3}</span><br><span style=\"color: #993366;\">　　[1 2 3 4]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {1,2,3,4}</span><br><span style=\"color: #993366;\">　　[1 2 3 4 6]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1,2,3,4,6}</span><br><span style=\"color: #993366;\">　　[1 2 3 4]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;{1,2,3,4,6}</span><br><span style=\"color: #993366;\">　　[1 2 3]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1,2,3,4,6}</span><br><span style=\"color: #993366;\">　　[1 2]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;{1,2,3,4,6}</span><br><span style=\"color: #993366;\">　　[1 2 5]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1,2,3,4,6,5}</span><br><span style=\"color: #993366;\">　　[1 2]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;{1,2,3,4,6,5}</span><br><span style=\"color: #993366;\">　　[1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1,2,3,4,6,5}</span></p> \n<p>　　当然，假如我们的目的是找到顶点6，那么到[1 2 3 4 6]时，1-&gt;2-&gt;3-&gt;4-&gt;6就是路径。</p> \n<p>&nbsp;</p> \n<p><span style=\"font-size: 18pt;\"><strong>其他问题</strong></span></p> \n<p>&nbsp;</p> \n<p>　　太多太多的问题其实都可以归结到这篇文章所说的内容来建模，甚至于，prolog语言都是基于回溯这样的模型设计的。</p> \n<p>　　当然，以下这样的迷宫问题自然可以很好的对接于这篇文章的内容，不过这个似乎看上去太过于明显了一点。</p> \n<p>&nbsp;</p> \n<p>　　<img src=\"null2019/01/03/29f0cefa-77f3-4358-973b-ae5ae49dbb20.jpeg\" alt=\"\"></p> \n<p>　　</p> \n<p>　　我再举一个更加复杂一点的游戏——华容道。这个游戏曾经出现在江苏电视台的《最强大脑》第五季中，以下是一个简化版的。</p> \n<p>&nbsp;</p> \n<p>　　<img src=\"null2019/01/03/cbbb5a3c-c0c6-4a92-aeaf-9456e033e97f.png\" alt=\"\"></p> \n<p>&nbsp;</p> \n<p>　　我们把9个位置的数字(如果是空则为0)序列当成状态，比如上面的状态为(0,8,7,6,5,4,3,2,1)，下面的状态为(1,2,3,4,5,6,7,8,0)。</p> \n<p>　　而每次移动则是原子操作，可以用所移动的数字来代表。</p> \n<p>　　有了状态和原子的抽象，华容道问题就可以归结于上述一样的抽象，从而可以统一解决。</p> \n<p>&nbsp;</p> \n<p><strong><span style=\"font-size: 18pt;\">代码</span></strong></p> \n<p>&nbsp;</p> \n<p>　　抽象的最终还是为了解决问题，程序的解决当然需要代码。</p> \n<p>　　如下链接文件用Python做了本章的抽象，以及狼羊白菜、倒油、迷宫、华容道各自的实现：</p> \n<p>　　　　　　　　　　　　　　　　　&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;　<a href=\"https://files.cnblogs.com/files/Colin-Cai/abstract.tar.gz\" target=\"_blank\"><img src=\"null2019/01/03/e319290b-d303-43ab-a99e-ca3b291f3185.png\" alt=\"\" width=\"27\" height=\"31\"></a></p>', '2019-01-03 17:10:52', 'https://www.cnblogs.com/Colin-Cai/p/7507317.html');
